{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mutiny \u2013 Intuitive Event-Driven Reactive Programming Library for Java # Uni < String > request = makeSomeNetworkRequest ( params ); request . ifNoItem (). after ( ofMillis ( 100 )) . failWith (() -> new TooSlowException ( \"\ud83d\udca5\" )) . onFailure ( IOException . class ). recoverWithItem ( fail -> \"\ud83d\udce6\" ) . subscribe (). with ( item -> log ( \"\ud83d\udc4d \" + item ), err -> log ( err . getMessage ()) ); Get Mutiny 2.1.0 Event-Driven # Mutiny places events at the core of its design. With Mutiny, you observe events , react to them, and create elegant and readable processing pipelines. A PhD in functional programming is not required. Navigable # Even with smart code completion, classes with hundreds of methods are confusing. Mutiny provides a navigable and explicit API driving you towards the operator you need. Non-blocking I/O # Mutiny is the perfect companion to tame the asynchronous nature of applications with non-blocking I/O. Compose operations in a declarative fashion, transform data, enforce progress, recover from failures and more. Quarkus and Vert.x native # Mutiny is integrated in Quarkus where every reactive API uses Mutiny, and Eclipse Vert.x clients are made available using Mutiny bindings. Mutiny is however an independent library that can ultimately be used in any Java application. Made for an asynchronous world # Mutiny can be used in any asynchronous application such as event-driven microservices, message-based applications, network utilities, data stream processing, and of course\u2026 reactive applications! Reactive Converters Built-In # Mutiny is based on the Reactive Streams protocol and Java Flow , and so it can be integrated with any other reactive programming library. In addition, it proposes converters to interact with other popular libraries.","title":"Home"},{"location":"#mutiny-intuitive-event-driven-reactive-programming-library-for-java","text":"Uni < String > request = makeSomeNetworkRequest ( params ); request . ifNoItem (). after ( ofMillis ( 100 )) . failWith (() -> new TooSlowException ( \"\ud83d\udca5\" )) . onFailure ( IOException . class ). recoverWithItem ( fail -> \"\ud83d\udce6\" ) . subscribe (). with ( item -> log ( \"\ud83d\udc4d \" + item ), err -> log ( err . getMessage ()) ); Get Mutiny 2.1.0","title":"Mutiny -- Intuitive Event-Driven Reactive Programming Library for Java"},{"location":"#event-driven","text":"Mutiny places events at the core of its design. With Mutiny, you observe events , react to them, and create elegant and readable processing pipelines. A PhD in functional programming is not required.","title":" Event-Driven"},{"location":"#navigable","text":"Even with smart code completion, classes with hundreds of methods are confusing. Mutiny provides a navigable and explicit API driving you towards the operator you need.","title":" Navigable"},{"location":"#non-blocking-io","text":"Mutiny is the perfect companion to tame the asynchronous nature of applications with non-blocking I/O. Compose operations in a declarative fashion, transform data, enforce progress, recover from failures and more.","title":" Non-blocking I/O"},{"location":"#quarkus-and-vertx-native","text":"Mutiny is integrated in Quarkus where every reactive API uses Mutiny, and Eclipse Vert.x clients are made available using Mutiny bindings. Mutiny is however an independent library that can ultimately be used in any Java application.","title":" Quarkus and Vert.x native"},{"location":"#made-for-an-asynchronous-world","text":"Mutiny can be used in any asynchronous application such as event-driven microservices, message-based applications, network utilities, data stream processing, and of course\u2026 reactive applications!","title":" Made for an asynchronous world"},{"location":"#reactive-converters-built-in","text":"Mutiny is based on the Reactive Streams protocol and Java Flow , and so it can be integrated with any other reactive programming library. In addition, it proposes converters to interact with other popular libraries.","title":" Reactive Converters Built-In"},{"location":"tags-index/","text":"Index # Document kinds # Tag Description tutorial Tutorials to get started with Mutiny. guides Topic-centric guides on how to use Mutiny. reference Reference documents to understand core concepts in Mutiny. Audience level # Tag Description beginner Reading materials if you are new to Mutiny intermediate Intermediate operations beyond the basics advanced Advanced operations beyond classic usage of Mutiny Tags # advanced # Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to deal with dropped exceptions? How can I integrate Mutiny with my framework? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Spying on events Publications beginner # Collecting items from Multi Eliminate duplicates and repetitions Filtering items from Multi How to handle null? Logging events Shortcut methods Take/Skip the first or last items How can I write unit / integration tests? Migrating to Mutiny 2 Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important? Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items guide # Collecting items from Multi Combining items from streams How to deal with CompletionStage? Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to delay events? How to deal with dropped exceptions? Eliminate duplicates and repetitions How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? Filtering items from Multi How can I integrate Mutiny with my framework? How to handle null? How to handle timeouts? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? Joining several unis Kotlin integration Logging events Merging and Concatenating Streams How to use paginated APIs? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Shortcut methods Spying on events Take/Skip the first or last items How can I write unit / integration tests? Dealing with checked exceptions intermediate # Combining items from streams How to deal with CompletionStage? How to delay events? How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? How to handle timeouts? Joining several unis Kotlin integration Merging and Concatenating Streams How to use paginated APIs? Dealing with checked exceptions reference # Migrating to Mutiny 2 Publications Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important? tutorial # Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items","title":"Tags index"},{"location":"tags-index/#index","text":"","title":"Index"},{"location":"tags-index/#document-kinds","text":"Tag Description tutorial Tutorials to get started with Mutiny. guides Topic-centric guides on how to use Mutiny. reference Reference documents to understand core concepts in Mutiny.","title":"Document kinds"},{"location":"tags-index/#audience-level","text":"Tag Description beginner Reading materials if you are new to Mutiny intermediate Intermediate operations beyond the basics advanced Advanced operations beyond classic usage of Mutiny","title":"Audience level"},{"location":"tags-index/#tags","text":"","title":"Tags"},{"location":"tags-index/#advanced","text":"Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to deal with dropped exceptions? How can I integrate Mutiny with my framework? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Spying on events Publications","title":"advanced"},{"location":"tags-index/#beginner","text":"Collecting items from Multi Eliminate duplicates and repetitions Filtering items from Multi How to handle null? Logging events Shortcut methods Take/Skip the first or last items How can I write unit / integration tests? Migrating to Mutiny 2 Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important? Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items","title":"beginner"},{"location":"tags-index/#guide","text":"Collecting items from Multi Combining items from streams How to deal with CompletionStage? Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to delay events? How to deal with dropped exceptions? Eliminate duplicates and repetitions How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? Filtering items from Multi How can I integrate Mutiny with my framework? How to handle null? How to handle timeouts? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? Joining several unis Kotlin integration Logging events Merging and Concatenating Streams How to use paginated APIs? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Shortcut methods Spying on events Take/Skip the first or last items How can I write unit / integration tests? Dealing with checked exceptions","title":"guide"},{"location":"tags-index/#intermediate","text":"Combining items from streams How to deal with CompletionStage? How to delay events? How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? How to handle timeouts? Joining several unis Kotlin integration Merging and Concatenating Streams How to use paginated APIs? Dealing with checked exceptions","title":"intermediate"},{"location":"tags-index/#reference","text":"Migrating to Mutiny 2 Publications Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important?","title":"reference"},{"location":"tags-index/#tutorial","text":"Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items","title":"tutorial"},{"location":"guides/collecting-items/","tags":["guide","beginner"],"text":"Collecting items from Multi # There are cases where you want to accumulate the items from a Multi and produce a Uni as a final result. This is also called a reduction in functional programming. The Uni fires its item when the Multi completes. Mutiny provides multiple operators to deal with that scenario. They are available from the collect() group. For example, you can store the items in a list, emit the list on completion, or use a Java Collector to customize the aggregation. Danger Don\u2019t collect items from infinite streams or you will likely end with an out-of-memory failure! Collecting items into a list # One of the most common approaches to collect items is to store them in a list ( Uni<List<T>> ) It emits the final list when the Multi completes. sequenceDiagram autonumber participant M as Multi participant O as Collect operator participant D as Subscriber M->>O: onItem(1) M->>O: onItem(2) M->>O: onItem(3) O->>D: onItem([1, 2, 3]) How to achieve this with Mutiny? 1 2 Multi < String > multi = getMulti (); Uni < List < String >> uni = multi . collect (). asList (); It\u2019s important to note that the returned type is a Uni . It emits the list when the multi completes. Collecting items into a map # You can also collect the items into a Map . In this case, you need to provide a function to compute the key for each item: 1 2 3 4 Multi < String > multi = getMulti (); Uni < Map < String , String >> uni = multi . collect () . asMap ( item -> getUniqueKeyForItem ( item )); If the key mapper function returns the same key for multiple items, the last one with that key is stored in the final Map . You can collect items in a multimap to handle items with the same keys. Collecting items into a multimap # A multimap is a Map<K, List<T>>. In the case of a conflicting key, it stores all the items in a list associated with that key. 1 2 3 4 Multi < String > multi = getMulti (); Uni < Map < String , Collection < String >>> uni = multi . collect () . asMultiMap ( item -> getKeyForItem ( item )); Using a custom accumulator # You can also use a custom accumulator function: 1 2 3 Multi < String > multi = getMulti (); Uni < MyCollection > uni = multi . collect () . in ( MyCollection :: new , ( col , item ) -> col . add ( item )); The in method receives two arguments: a supplier providing the new instance of your collection/container the accumulator function You can also use a Java Collector . For example, in the next example, count the number of items, and produce the final count as item: 1 2 Uni < Long > count = multi . collect () . with ( Collectors . counting ()); Getting the first and last items # While they are not strictly speaking collecting items, collect().first() and collect().last() allow retrieving the first and last item from a Multi : 1 2 Uni < String > first = multi . collect (). first (); Uni < String > last = multi . collect (). last ();","title":"Collecting items from Multi"},{"location":"guides/collecting-items/#collecting-items-from-multi","text":"There are cases where you want to accumulate the items from a Multi and produce a Uni as a final result. This is also called a reduction in functional programming. The Uni fires its item when the Multi completes. Mutiny provides multiple operators to deal with that scenario. They are available from the collect() group. For example, you can store the items in a list, emit the list on completion, or use a Java Collector to customize the aggregation. Danger Don\u2019t collect items from infinite streams or you will likely end with an out-of-memory failure!","title":"Collecting items from Multi"},{"location":"guides/collecting-items/#collecting-items-into-a-list","text":"One of the most common approaches to collect items is to store them in a list ( Uni<List<T>> ) It emits the final list when the Multi completes. sequenceDiagram autonumber participant M as Multi participant O as Collect operator participant D as Subscriber M->>O: onItem(1) M->>O: onItem(2) M->>O: onItem(3) O->>D: onItem([1, 2, 3]) How to achieve this with Mutiny? 1 2 Multi < String > multi = getMulti (); Uni < List < String >> uni = multi . collect (). asList (); It\u2019s important to note that the returned type is a Uni . It emits the list when the multi completes.","title":"Collecting items into a list"},{"location":"guides/collecting-items/#collecting-items-into-a-map","text":"You can also collect the items into a Map . In this case, you need to provide a function to compute the key for each item: 1 2 3 4 Multi < String > multi = getMulti (); Uni < Map < String , String >> uni = multi . collect () . asMap ( item -> getUniqueKeyForItem ( item )); If the key mapper function returns the same key for multiple items, the last one with that key is stored in the final Map . You can collect items in a multimap to handle items with the same keys.","title":"Collecting items into a map"},{"location":"guides/collecting-items/#collecting-items-into-a-multimap","text":"A multimap is a Map<K, List<T>>. In the case of a conflicting key, it stores all the items in a list associated with that key. 1 2 3 4 Multi < String > multi = getMulti (); Uni < Map < String , Collection < String >>> uni = multi . collect () . asMultiMap ( item -> getKeyForItem ( item ));","title":"Collecting items into a multimap"},{"location":"guides/collecting-items/#using-a-custom-accumulator","text":"You can also use a custom accumulator function: 1 2 3 Multi < String > multi = getMulti (); Uni < MyCollection > uni = multi . collect () . in ( MyCollection :: new , ( col , item ) -> col . add ( item )); The in method receives two arguments: a supplier providing the new instance of your collection/container the accumulator function You can also use a Java Collector . For example, in the next example, count the number of items, and produce the final count as item: 1 2 Uni < Long > count = multi . collect () . with ( Collectors . counting ());","title":"Using a custom accumulator"},{"location":"guides/collecting-items/#getting-the-first-and-last-items","text":"While they are not strictly speaking collecting items, collect().first() and collect().last() allow retrieving the first and last item from a Multi : 1 2 Uni < String > first = multi . collect (). first (); Uni < String > last = multi . collect (). last ();","title":"Getting the first and last items"},{"location":"guides/combining-items/","tags":["guide","intermediate"],"text":"Combining items from streams # Combining items from various streams is an essential pattern in Reactive Programming. It associates the emitted items from multiple streams and emits an aggregate . The downstream receives this aggregate and can handle it smoothly. There are plenty of use cases, such as executing two tasks concurrently and waiting for both completions, getting the last items from different streams to build an always up-to-date view, and so on. Combining Unis # Imagine that you have two asynchronous operations to perform like 2 HTTP requests. You want to send these requests and be notified when both have completed with their responses ready to be consumed. Of course, you could send the first request, wait for the response, and then send the second request. If both requests are independent, we can do something better: send both concurrently and await for both completions! sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Combined stream participant S as Subscriber A->>M: onItem(1) B->>M: onItem(a) M->>S: onItem([1,a]) A->>M: onItem(2) B->>M: onItem(b) M->>S: onItem([2,b]) How can you achieve this with Mutiny? First, each request is a Uni , so we have: 1 2 Uni < Response > uniA = invokeHttpServiceA (); Uni < Response > uniB = invokeHttpServiceB (); Then, we want to combine both responses : 1 2 Uni < Tuple2 < Response , Response >> responses = Uni . combine () . all (). unis ( uniA , uniB ). asTuple (); This code creates a new Uni produced by combining uniA and uniB . The responses are aggregated inside a Tuple : 1 2 3 4 5 Uni . combine (). all (). unis ( uniA , uniB ). asTuple () . subscribe (). with ( tuple -> { System . out . println ( \"Response from A: \" + tuple . getItem1 ()); System . out . println ( \"Response from B: \" + tuple . getItem2 ()); }); The tuple aggregates the responses in the same order as the Uni sequence. If one of the Uni fails, so does the combination and you receive the failure: 1 2 3 4 5 6 7 8 9 10 11 Uni < Response > uniA = invokeHttpServiceA (); Uni < Response > uniB = invokeHttpServiceB (); Uni < Tuple2 < Response , Response >> responses = Uni . combine () . all (). unis ( uniA , uniB ). asTuple (); Uni . combine (). all (). unis ( uniA , uniB ). asTuple () . subscribe (). with ( tuple -> { System . out . println ( \"Response from A: \" + tuple . getItem1 ()); System . out . println ( \"Response from B: \" + tuple . getItem2 ()); }); Using tuples is convenient but only works if you have less than 10 Uni objects. If you want another structure or deal with 10 Uni objects or more then use combineWith : 1 2 3 4 5 6 7 8 9 Uni < Map < String , Response >> uni = Uni . combine () . all (). unis ( uniA , uniB ). combinedWith ( listOfResponses -> { Map < String , Response > map = new LinkedHashMap <> (); map . put ( \"A\" , ( Response ) listOfResponses . get ( 0 )); map . put ( \"B\" , ( Response ) listOfResponses . get ( 1 )); return map ; } ); Combining Multis # Combining Multis consists of associating items from different stream per index : sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Combined stream participant S as Subscriber A->>M: onItem(1) A->>M: onItem(2) B->>M: onItem(a) M->>S: onItem([1,a]) A->>M: onItem(3) B->>M: onItem(b) M->>S: onItem([2,b]) B->>M: onItem(c) It associates the first items from the combined streams, then the second items: 1 2 Multi < Tuple2 < A , B >> combined = Multi . createBy (). combining () . streams ( multiA , multiB ). asTuple (); As for Uni , you can aggregate the item into tuples (up to 9 items) or combine with a combinator function: 1 2 3 4 5 Multi . createBy (). combining () . streams ( multiA , multiB ). using ( list -> combineItems ( list )) . subscribe (). with ( x -> { // do something with the combined items }); If one of the streams fails, the combined stream propagates the failure and stops the emission. The combined stream completes as soon as one of the observed stream sends the completion event. Note If one of the observed streams never emits any item then the combined stream will not emit anything. Combining the latest items of Multis # It can be useful to combine multiple Multi streams and receive the latest items from each stream on every emission: sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Combined stream participant S as Subscriber A->>M: onItem(1) A->>M: onItem(2) B->>M: onItem(a) M->>S: onItem([2,a]) A->>M: onItem(3) M->>S: onItem([3,a]) B->>M: onItem(b) M->>S: onItem([3,b]) B->>M: onItem(c) M->>S: onItem([3,c]) This is achieved using latest() : 1 2 3 4 5 6 7 8 9 Multi < Tuple2 < A , B >> multi1 = Multi . createBy (). combining () . streams ( multiA , multiB ) . latestItems (). asTuple (); // or Multi < String > multi2 = Multi . createBy (). combining () . streams ( multiA , multiB ) . latestItems (). using ( list -> combineItems ( list ));","title":"Combining items from streams"},{"location":"guides/combining-items/#combining-items-from-streams","text":"Combining items from various streams is an essential pattern in Reactive Programming. It associates the emitted items from multiple streams and emits an aggregate . The downstream receives this aggregate and can handle it smoothly. There are plenty of use cases, such as executing two tasks concurrently and waiting for both completions, getting the last items from different streams to build an always up-to-date view, and so on.","title":"Combining items from streams"},{"location":"guides/combining-items/#combining-unis","text":"Imagine that you have two asynchronous operations to perform like 2 HTTP requests. You want to send these requests and be notified when both have completed with their responses ready to be consumed. Of course, you could send the first request, wait for the response, and then send the second request. If both requests are independent, we can do something better: send both concurrently and await for both completions! sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Combined stream participant S as Subscriber A->>M: onItem(1) B->>M: onItem(a) M->>S: onItem([1,a]) A->>M: onItem(2) B->>M: onItem(b) M->>S: onItem([2,b]) How can you achieve this with Mutiny? First, each request is a Uni , so we have: 1 2 Uni < Response > uniA = invokeHttpServiceA (); Uni < Response > uniB = invokeHttpServiceB (); Then, we want to combine both responses : 1 2 Uni < Tuple2 < Response , Response >> responses = Uni . combine () . all (). unis ( uniA , uniB ). asTuple (); This code creates a new Uni produced by combining uniA and uniB . The responses are aggregated inside a Tuple : 1 2 3 4 5 Uni . combine (). all (). unis ( uniA , uniB ). asTuple () . subscribe (). with ( tuple -> { System . out . println ( \"Response from A: \" + tuple . getItem1 ()); System . out . println ( \"Response from B: \" + tuple . getItem2 ()); }); The tuple aggregates the responses in the same order as the Uni sequence. If one of the Uni fails, so does the combination and you receive the failure: 1 2 3 4 5 6 7 8 9 10 11 Uni < Response > uniA = invokeHttpServiceA (); Uni < Response > uniB = invokeHttpServiceB (); Uni < Tuple2 < Response , Response >> responses = Uni . combine () . all (). unis ( uniA , uniB ). asTuple (); Uni . combine (). all (). unis ( uniA , uniB ). asTuple () . subscribe (). with ( tuple -> { System . out . println ( \"Response from A: \" + tuple . getItem1 ()); System . out . println ( \"Response from B: \" + tuple . getItem2 ()); }); Using tuples is convenient but only works if you have less than 10 Uni objects. If you want another structure or deal with 10 Uni objects or more then use combineWith : 1 2 3 4 5 6 7 8 9 Uni < Map < String , Response >> uni = Uni . combine () . all (). unis ( uniA , uniB ). combinedWith ( listOfResponses -> { Map < String , Response > map = new LinkedHashMap <> (); map . put ( \"A\" , ( Response ) listOfResponses . get ( 0 )); map . put ( \"B\" , ( Response ) listOfResponses . get ( 1 )); return map ; } );","title":"Combining Unis"},{"location":"guides/combining-items/#combining-multis","text":"Combining Multis consists of associating items from different stream per index : sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Combined stream participant S as Subscriber A->>M: onItem(1) A->>M: onItem(2) B->>M: onItem(a) M->>S: onItem([1,a]) A->>M: onItem(3) B->>M: onItem(b) M->>S: onItem([2,b]) B->>M: onItem(c) It associates the first items from the combined streams, then the second items: 1 2 Multi < Tuple2 < A , B >> combined = Multi . createBy (). combining () . streams ( multiA , multiB ). asTuple (); As for Uni , you can aggregate the item into tuples (up to 9 items) or combine with a combinator function: 1 2 3 4 5 Multi . createBy (). combining () . streams ( multiA , multiB ). using ( list -> combineItems ( list )) . subscribe (). with ( x -> { // do something with the combined items }); If one of the streams fails, the combined stream propagates the failure and stops the emission. The combined stream completes as soon as one of the observed stream sends the completion event. Note If one of the observed streams never emits any item then the combined stream will not emit anything.","title":"Combining Multis"},{"location":"guides/combining-items/#combining-the-latest-items-of-multis","text":"It can be useful to combine multiple Multi streams and receive the latest items from each stream on every emission: sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Combined stream participant S as Subscriber A->>M: onItem(1) A->>M: onItem(2) B->>M: onItem(a) M->>S: onItem([2,a]) A->>M: onItem(3) M->>S: onItem([3,a]) B->>M: onItem(b) M->>S: onItem([3,b]) B->>M: onItem(c) M->>S: onItem([3,c]) This is achieved using latest() : 1 2 3 4 5 6 7 8 9 Multi < Tuple2 < A , B >> multi1 = Multi . createBy (). combining () . streams ( multiA , multiB ) . latestItems (). asTuple (); // or Multi < String > multi2 = Multi . createBy (). combining () . streams ( multiA , multiB ) . latestItems (). using ( list -> combineItems ( list ));","title":"Combining the latest items of Multis"},{"location":"guides/completion-stage/","tags":["guide","intermediate"],"text":"How to deal with CompletionStage? # CompletionStage and CompletableFuture are classes provided by Java to represent asynchronous actions. Differences between Uni and CompletionStage # While CompletionStage and CompletableFuture are close to Uni in terms of use case, there are some fundamental differences. CompletionStage are eager . When a method returns a CompletionStage, the operation has already been triggered. The outcome is used to complete the returned CompletionStage . On the other side, Unis are lazy. The operation is only triggered once there is a subscription. CompletionStage caches the outcome. So, once received, you can retrieve the result. Every retrieval will get the same result. With Uni , every subscription has the opportunity to re-trigger the operation and gets a different result. Tip You can also cache the outcome with Uni.memoize().indefinitely() . From Uni to CompletionStage # You can create a CompletionStage from Uni using uni.subscribeAsCompletionStage() . 1 CompletionStage < String > cs = uni . subscribeAsCompletionStage (); It\u2019s important to understand that retrieving a CompletionStage subscribes to the Uni . If you do this operation twice, it subscribes to the Uni twice and re-trigger the operation. 1 2 3 // Trigger the underlying operation twice: CompletionStage < String > cs1 = uni . subscribeAsCompletionStage (); CompletionStage < String > cs2 = uni . subscribeAsCompletionStage (); Creating a Uni from a CompletionStage # To create a Uni from a CompletionStage , use Uni.createFrom().completionStage(...) . 1 2 3 4 5 6 7 8 9 10 11 12 13 Uni < String > uni1 = Uni // Create from a Completion Stage . createFrom (). completionStage ( CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); Uni < String > uni2 = Uni // Create from a Completion Stage supplier (recommended) . createFrom (). completionStage ( () -> CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); As you can see, there are two versions. The first one receives the CompletionStage directly, while the second one gets a supplier. In the case of multiple subscriptions on the produced Uni , the supplier is called multiple times (once per subscription), and so can change the return CompletionStage . It also delays the creation of the CompletionStage until there is a subscription, which only triggers the operation at that time. If you pass the instance directly, it will always use the same one (even for multiple subscriptions) and triggers the operation even if there is no subscription. For these reasons, it is generally better to use the variant accepting a supplier. Note that if the completion stage produces a null value, the resulting Uni emits null as item. If the completion stages complete exceptionally, the failure is emitted by the resulting Uni . Creating a Multi from a CompletionStage # To create a Multi from a CompletionStage , use Multi.createFrom().completionStage(...) . It produces: a multi emitting an item and completing - if the value produced by the completion stage is not null , an empty multi if the value produced by the completion stage is null , a failed multi is completion stage is completed exceptionally. 1 2 3 4 5 6 7 8 9 10 11 Multi < String > multi1 = Multi . createFrom (). completionStage ( CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); Multi < String > multi2 = Multi . createFrom (). completionStage (() -> CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); For the same reason as for Uni , there are two versions: one accepting a CompletionStage directly one accepting a Supplier<CompletionStage> , called at subscription-time, for every subscription. It is recommended to use the second version.","title":"How to deal with CompletionStage?"},{"location":"guides/completion-stage/#how-to-deal-with-completionstage","text":"CompletionStage and CompletableFuture are classes provided by Java to represent asynchronous actions.","title":"How to deal with CompletionStage?"},{"location":"guides/completion-stage/#differences-between-uni-and-completionstage","text":"While CompletionStage and CompletableFuture are close to Uni in terms of use case, there are some fundamental differences. CompletionStage are eager . When a method returns a CompletionStage, the operation has already been triggered. The outcome is used to complete the returned CompletionStage . On the other side, Unis are lazy. The operation is only triggered once there is a subscription. CompletionStage caches the outcome. So, once received, you can retrieve the result. Every retrieval will get the same result. With Uni , every subscription has the opportunity to re-trigger the operation and gets a different result. Tip You can also cache the outcome with Uni.memoize().indefinitely() .","title":"Differences between Uni and CompletionStage"},{"location":"guides/completion-stage/#from-uni-to-completionstage","text":"You can create a CompletionStage from Uni using uni.subscribeAsCompletionStage() . 1 CompletionStage < String > cs = uni . subscribeAsCompletionStage (); It\u2019s important to understand that retrieving a CompletionStage subscribes to the Uni . If you do this operation twice, it subscribes to the Uni twice and re-trigger the operation. 1 2 3 // Trigger the underlying operation twice: CompletionStage < String > cs1 = uni . subscribeAsCompletionStage (); CompletionStage < String > cs2 = uni . subscribeAsCompletionStage ();","title":"From Uni to CompletionStage"},{"location":"guides/completion-stage/#creating-a-uni-from-a-completionstage","text":"To create a Uni from a CompletionStage , use Uni.createFrom().completionStage(...) . 1 2 3 4 5 6 7 8 9 10 11 12 13 Uni < String > uni1 = Uni // Create from a Completion Stage . createFrom (). completionStage ( CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); Uni < String > uni2 = Uni // Create from a Completion Stage supplier (recommended) . createFrom (). completionStage ( () -> CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); As you can see, there are two versions. The first one receives the CompletionStage directly, while the second one gets a supplier. In the case of multiple subscriptions on the produced Uni , the supplier is called multiple times (once per subscription), and so can change the return CompletionStage . It also delays the creation of the CompletionStage until there is a subscription, which only triggers the operation at that time. If you pass the instance directly, it will always use the same one (even for multiple subscriptions) and triggers the operation even if there is no subscription. For these reasons, it is generally better to use the variant accepting a supplier. Note that if the completion stage produces a null value, the resulting Uni emits null as item. If the completion stages complete exceptionally, the failure is emitted by the resulting Uni .","title":"Creating a Uni from a CompletionStage"},{"location":"guides/completion-stage/#creating-a-multi-from-a-completionstage","text":"To create a Multi from a CompletionStage , use Multi.createFrom().completionStage(...) . It produces: a multi emitting an item and completing - if the value produced by the completion stage is not null , an empty multi if the value produced by the completion stage is null , a failed multi is completion stage is completed exceptionally. 1 2 3 4 5 6 7 8 9 10 11 Multi < String > multi1 = Multi . createFrom (). completionStage ( CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); Multi < String > multi2 = Multi . createFrom (). completionStage (() -> CompletableFuture . supplyAsync (() -> \"hello\" , executor ) ) . onItem (). transform ( String :: toUpperCase ); For the same reason as for Uni , there are two versions: one accepting a CompletionStage directly one accepting a Supplier<CompletionStage> , called at subscription-time, for every subscription. It is recommended to use the second version.","title":"Creating a Multi from a CompletionStage"},{"location":"guides/context-passing/","tags":["guide","advanced"],"text":"Context passing # Mutiny reactive pipelines let data flow from publishers to subscribers. In the vast majority of cases a publisher shall have all required data, and operators shall perform processing based on item values. For instance a network request shall be made with all request data known in advance, and response processing shall only depend on the response payload. That being said there are cases were this is not sufficient, and some data has to be carried along with items. For instance one intermediary operator in a pipeline may have to make another networked request from which we need to extract some correlation identifier which will be used by another operator down the pipeline. In such cases one will be tempted to forward tuples consisting of some item value plus some \u201cextra\u201d data. For such cases Mutiny offers a subscriber-provided context , so all operators involved in a subscription can share some form of implicit data . What\u2019s in a context? # A context is a simple key / value, in-memory storage. Data can be queried, added and deleted from a context, as shown in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Create a context using key / value pairs Context context = Context . of ( \"X-CUSTOMER-ID\" , \"1234\" , \"X-SPAN-ID\" , \"foo-bar-baz\" ); // Get an entry System . out . println ( context . < String > get ( \"X-SPAN-ID\" )); // Get an entry, use a supplier for a default value if the key is not present System . out . println ( context . getOrElse ( \"X-SPAN-ID\" , () -> \"<no id>\" )); // Add an entry context . put ( \"foo\" , \"bar\" ); // Remove an entry context . delete ( \"foo\" ); Context objects are thread-safe, and can be created from sequences of key / value pairs (as shown above), from a Java Map , or they can be created empty. Note that an empty-created context defers its internal storage allocation until the first call to put . You can see Context as a glorified ConcurrentHashMap delegate, although this is an implementation detail and Mutiny might explore various internal storage strategies in the future. Tip Contexts shall be primarily used to share transient data used for networked I/O processing such as correlation identifiers, tokens, etc. They should not be used as general-purpose data structures that are frequently updated and that hold large amounts of data. How to access a context? # Given a Uni or a Multi , a context can be accessed using the withContext operator, as in: 1 2 3 4 Context context = Context . of ( \"X-CUSTOMER-ID\" , customerId ); pipeline . withContext (( multi , ctx ) -> multi . onItem (). transformToUniAndMerge ( item -> makeRequest ( item , ctx . get ( \"X-CUSTOMER-ID\" )))) . subscribe (). with ( context , item -> handleResponse ( item ), err -> handleFailure ( err )); This operator builds a sub-pipeline using 2 parameters: the current Uni or Multi and the context. Important The function passed to withContext is called at subscription time. This means that the context has not had a chance to be updated by upstream operators yet, so be careful with what you do in the body of that function. There is another way to access the context by using the attachContext method: 1 2 3 4 5 Context context = Context . of ( \"X-CUSTOMER-ID\" , customerId ); pipeline . attachContext () . onItem (). transformToUniAndMerge ( item -> makeRequest ( item . get (), item . context (). get ( \"X-CUSTOMER-ID\" ))) . subscribe (). with ( context , item -> handleResponse ( item ), err -> handleFailure ( err )); This method materializes the context in the regular pipeline items using the wrapper ItemWithContext class. The get method provides the item while the context method provides the context. How to access a context at the pipeline source? # The Uni and Multi builder methods like Multi.createFrom() provide publishers, not operators, so they don\u2019t have the withContext method. The first option is to use the Uni.createFrom().context(...) or Multi.createFrom().context(...) general purpose method to materialize the context: 1 2 Uni . createFrom (). context ( ctx -> makeRequest ( \"db1\" , ctx . get ( \"X-SPAN-ID\" ))) . subscribe (). with ( context , item -> handleResponse ( item ), err -> handleFailure ( err )); The context method takes a function that accepts a Context and returns a pipeline. This is very similar to the deferred builder. If you use an emitter builder then for both Uni and Multi cases the emitter object offers a context method to access the context: 1 2 3 4 5 6 7 Multi . createFrom (). emitter ( emitter -> { String customerId = emitter . context (). get ( \"X-SPAN-ID\" ); for ( int i = 0 ; i < 10 ; i ++ ) { emitter . emit ( \"@\" + i + \" [\" + customerId + \"]\" ); } emitter . complete (); });","title":"Context passing"},{"location":"guides/context-passing/#context-passing","text":"Mutiny reactive pipelines let data flow from publishers to subscribers. In the vast majority of cases a publisher shall have all required data, and operators shall perform processing based on item values. For instance a network request shall be made with all request data known in advance, and response processing shall only depend on the response payload. That being said there are cases were this is not sufficient, and some data has to be carried along with items. For instance one intermediary operator in a pipeline may have to make another networked request from which we need to extract some correlation identifier which will be used by another operator down the pipeline. In such cases one will be tempted to forward tuples consisting of some item value plus some \u201cextra\u201d data. For such cases Mutiny offers a subscriber-provided context , so all operators involved in a subscription can share some form of implicit data .","title":"Context passing"},{"location":"guides/context-passing/#whats-in-a-context","text":"A context is a simple key / value, in-memory storage. Data can be queried, added and deleted from a context, as shown in the following snippet: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // Create a context using key / value pairs Context context = Context . of ( \"X-CUSTOMER-ID\" , \"1234\" , \"X-SPAN-ID\" , \"foo-bar-baz\" ); // Get an entry System . out . println ( context . < String > get ( \"X-SPAN-ID\" )); // Get an entry, use a supplier for a default value if the key is not present System . out . println ( context . getOrElse ( \"X-SPAN-ID\" , () -> \"<no id>\" )); // Add an entry context . put ( \"foo\" , \"bar\" ); // Remove an entry context . delete ( \"foo\" ); Context objects are thread-safe, and can be created from sequences of key / value pairs (as shown above), from a Java Map , or they can be created empty. Note that an empty-created context defers its internal storage allocation until the first call to put . You can see Context as a glorified ConcurrentHashMap delegate, although this is an implementation detail and Mutiny might explore various internal storage strategies in the future. Tip Contexts shall be primarily used to share transient data used for networked I/O processing such as correlation identifiers, tokens, etc. They should not be used as general-purpose data structures that are frequently updated and that hold large amounts of data.","title":"What's in a context?"},{"location":"guides/context-passing/#how-to-access-a-context","text":"Given a Uni or a Multi , a context can be accessed using the withContext operator, as in: 1 2 3 4 Context context = Context . of ( \"X-CUSTOMER-ID\" , customerId ); pipeline . withContext (( multi , ctx ) -> multi . onItem (). transformToUniAndMerge ( item -> makeRequest ( item , ctx . get ( \"X-CUSTOMER-ID\" )))) . subscribe (). with ( context , item -> handleResponse ( item ), err -> handleFailure ( err )); This operator builds a sub-pipeline using 2 parameters: the current Uni or Multi and the context. Important The function passed to withContext is called at subscription time. This means that the context has not had a chance to be updated by upstream operators yet, so be careful with what you do in the body of that function. There is another way to access the context by using the attachContext method: 1 2 3 4 5 Context context = Context . of ( \"X-CUSTOMER-ID\" , customerId ); pipeline . attachContext () . onItem (). transformToUniAndMerge ( item -> makeRequest ( item . get (), item . context (). get ( \"X-CUSTOMER-ID\" ))) . subscribe (). with ( context , item -> handleResponse ( item ), err -> handleFailure ( err )); This method materializes the context in the regular pipeline items using the wrapper ItemWithContext class. The get method provides the item while the context method provides the context.","title":"How to access a context?"},{"location":"guides/context-passing/#how-to-access-a-context-at-the-pipeline-source","text":"The Uni and Multi builder methods like Multi.createFrom() provide publishers, not operators, so they don\u2019t have the withContext method. The first option is to use the Uni.createFrom().context(...) or Multi.createFrom().context(...) general purpose method to materialize the context: 1 2 Uni . createFrom (). context ( ctx -> makeRequest ( \"db1\" , ctx . get ( \"X-SPAN-ID\" ))) . subscribe (). with ( context , item -> handleResponse ( item ), err -> handleFailure ( err )); The context method takes a function that accepts a Context and returns a pipeline. This is very similar to the deferred builder. If you use an emitter builder then for both Uni and Multi cases the emitter object offers a context method to access the context: 1 2 3 4 5 6 7 Multi . createFrom (). emitter ( emitter -> { String customerId = emitter . context (). get ( \"X-SPAN-ID\" ); for ( int i = 0 ; i < 10 ; i ++ ) { emitter . emit ( \"@\" + i + \" [\" + customerId + \"]\" ); } emitter . complete (); });","title":"How to access a context at the pipeline source?"},{"location":"guides/controlling-demand/","tags":["guide","advanced"],"text":"Controlling the demand # Pacing the demand # A subscription is used for 2 purposes: cancelling a request and demanding batches of items. The Multi.paceDemand() operator can be used to automatically issue requests at certain points in time. The following example issues requests of 25 items every 100ms: 1 2 3 4 FixedDemandPacer pacer = new FixedDemandPacer ( 25L , Duration . ofMillis ( 100L )); Multi < Integer > multi = Multi . createFrom (). range ( 0 , 100 ) . paceDemand (). on ( Infrastructure . getDefaultWorkerPool ()). using ( pacer ); FixedDemandPacer is a simple pacer with a fixed demand and a fixed delay. You can create more elaborated pacers by implementing the DemandPacer interface. To do so you provide an initial request and a function to evaluate the next request which is evaluated based on the previous request and the number of items emitted since the last request: 1 2 3 4 5 6 7 8 9 10 11 12 DemandPacer pacer = new DemandPacer () { @Override public Request initial () { return new Request ( 10L , Duration . ofMillis ( 100L )); } @Override public Request apply ( Request previousRequest , long observedItemsCount ) { return new Request ( previousRequest . demand () * 2 , previousRequest . delay (). plus ( 10 , ChronoUnit . MILLIS )); } }; The previous example is a custom pacer that doubles the demand and increases the delay for each new request. Capping the demand requests # The capDemandsTo and capDemandUsing operators can be used to cap the demand from downstream subscribers. The capDemandTo operator defines a maximum demand that can flow: 1 2 3 4 5 6 7 8 9 10 11 12 13 AssertSubscriber < Integer > sub = AssertSubscriber . create (); sub = Multi . createFrom (). range ( 0 , 100 ) . capDemandsTo ( 50L ) . subscribe (). withSubscriber ( sub ); // A first batch of 50 (capped), 25 remain outstanding sub . request ( 75L ). assertNotTerminated (); assertThat ( sub . getItems ()). hasSize ( 50 ); // Second batch: 25 + 25 = 50 sub . request ( 25L ). assertCompleted (); assertThat ( sub . getItems ()). hasSize ( 100 ); Here we cap requests to 50 items, so it takes 2 requests to get all 100 items of the upstream range. The first request of 75 items is capped to a request of 50 items, leaving an outstanding demand of 25 items. The second request of 25 items is added to the outstanding demand, resulting in a request of 50 items and completing the stream. You can also define a custom function that provides a capping value based on a custom formula, or based on earlier demand observations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 AssertSubscriber < Integer > sub = AssertSubscriber . create (); sub = Multi . createFrom (). range ( 0 , 100 ) . capDemandsUsing ( n -> { if ( n > 1 ) { return ( long ) ((( double ) n ) * 0.75d ); } else { return n ; } }) . subscribe (). withSubscriber ( sub ); sub . request ( 100L ). assertNotTerminated (); assertThat ( sub . getItems ()). hasSize ( 75 ); sub . request ( 1L ). assertNotTerminated (); assertThat ( sub . getItems ()). hasSize ( 94 ); sub . request ( Long . MAX_VALUE ). assertCompleted (); assertThat ( sub . getItems ()). hasSize ( 100 ); Here we have a function that requests 75% of the downstream requests. Note that the function must return a value n that satisfies (0 < n <= requested) where requested is the downstream demand.","title":"Controlling the demand"},{"location":"guides/controlling-demand/#controlling-the-demand","text":"","title":"Controlling the demand"},{"location":"guides/controlling-demand/#pacing-the-demand","text":"A subscription is used for 2 purposes: cancelling a request and demanding batches of items. The Multi.paceDemand() operator can be used to automatically issue requests at certain points in time. The following example issues requests of 25 items every 100ms: 1 2 3 4 FixedDemandPacer pacer = new FixedDemandPacer ( 25L , Duration . ofMillis ( 100L )); Multi < Integer > multi = Multi . createFrom (). range ( 0 , 100 ) . paceDemand (). on ( Infrastructure . getDefaultWorkerPool ()). using ( pacer ); FixedDemandPacer is a simple pacer with a fixed demand and a fixed delay. You can create more elaborated pacers by implementing the DemandPacer interface. To do so you provide an initial request and a function to evaluate the next request which is evaluated based on the previous request and the number of items emitted since the last request: 1 2 3 4 5 6 7 8 9 10 11 12 DemandPacer pacer = new DemandPacer () { @Override public Request initial () { return new Request ( 10L , Duration . ofMillis ( 100L )); } @Override public Request apply ( Request previousRequest , long observedItemsCount ) { return new Request ( previousRequest . demand () * 2 , previousRequest . delay (). plus ( 10 , ChronoUnit . MILLIS )); } }; The previous example is a custom pacer that doubles the demand and increases the delay for each new request.","title":"Pacing the demand"},{"location":"guides/controlling-demand/#capping-the-demand-requests","text":"The capDemandsTo and capDemandUsing operators can be used to cap the demand from downstream subscribers. The capDemandTo operator defines a maximum demand that can flow: 1 2 3 4 5 6 7 8 9 10 11 12 13 AssertSubscriber < Integer > sub = AssertSubscriber . create (); sub = Multi . createFrom (). range ( 0 , 100 ) . capDemandsTo ( 50L ) . subscribe (). withSubscriber ( sub ); // A first batch of 50 (capped), 25 remain outstanding sub . request ( 75L ). assertNotTerminated (); assertThat ( sub . getItems ()). hasSize ( 50 ); // Second batch: 25 + 25 = 50 sub . request ( 25L ). assertCompleted (); assertThat ( sub . getItems ()). hasSize ( 100 ); Here we cap requests to 50 items, so it takes 2 requests to get all 100 items of the upstream range. The first request of 75 items is capped to a request of 50 items, leaving an outstanding demand of 25 items. The second request of 25 items is added to the outstanding demand, resulting in a request of 50 items and completing the stream. You can also define a custom function that provides a capping value based on a custom formula, or based on earlier demand observations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 AssertSubscriber < Integer > sub = AssertSubscriber . create (); sub = Multi . createFrom (). range ( 0 , 100 ) . capDemandsUsing ( n -> { if ( n > 1 ) { return ( long ) ((( double ) n ) * 0.75d ); } else { return n ; } }) . subscribe (). withSubscriber ( sub ); sub . request ( 100L ). assertNotTerminated (); assertThat ( sub . getItems ()). hasSize ( 75 ); sub . request ( 1L ). assertNotTerminated (); assertThat ( sub . getItems ()). hasSize ( 94 ); sub . request ( Long . MAX_VALUE ). assertCompleted (); assertThat ( sub . getItems ()). hasSize ( 100 ); Here we have a function that requests 75% of the downstream requests. Note that the function must return a value n that satisfies (0 < n <= requested) where requested is the downstream demand.","title":"Capping the demand requests"},{"location":"guides/converters/","tags":["guide","advanced"],"text":"Using other reactive programming libraries # You may need to integrate libraries exposing an API using other reactive programming libraries such as RX Java or Reactor. Mutiny has a built-in conversion mechanism to ease that integration. Picking the right dependency # You need to add another dependency to access the converters. Each artifact contains the converters for a specific reactive library. Pick the right one and add it to your project: Reactor RxJava 3 <!-- Mutiny <-> Reactor --> <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-reactor </artifactId> <version> 2.1.0 </version> </dependency> <!-- Mutiny <-> RX Java 3 --> <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-rxjava3 </artifactId> <version> 2.1.0 </version> </dependency> Integration with Project Reactor # Project Reactor is a popular reactive programming library. It offers two types: Mono and Flux, both implementing Reactive Stream Publisher . To use the Reactor <-> Mutiny converter, add the following imports to your class: import io.smallrye.mutiny.converters.multi.MultiReactorConverters ; import io.smallrye.mutiny.converters.uni.UniReactorConverters ; Converting a Flux or a Mono into a Multi # Both Flux and Mono implement Publisher . As a result, we can use the Reactive Streams interoperability to convert instances from Flux<T> and Mono<T> to Multi<T> : 1 2 3 4 5 Flow . Publisher < T > fluxAsPublisher = AdaptersToFlow . publisher ( flux ); Multi < T > multiFromFlux = Multi . createFrom (). publisher ( fluxAsPublisher ); Flow . Publisher < T > monoAsPublisher = AdaptersToFlow . publisher ( mono ); Multi < T > multiFromMono = Multi . createFrom (). publisher ( monoAsPublisher ); Attention Reactor still uses the legacy Reactive Streams APIs instead of java.util.concurrent.Flow , so you need to perform an adaptation. We recommend using the Mutiny Zero Flow Adapters library as in these examples (Maven coordinates io.smallrye.reactive:mutiny-zero-flow-adapters ). Converting a Flux or a Mono into a Uni # As you can create Uni from a Publisher , the same approach can be used to create Uni instances: 1 2 3 4 5 Flow . Publisher < T > fluxAsPublisher = AdaptersToFlow . publisher ( flux ); Uni < T > uniFromFlux = Uni . createFrom (). publisher ( fluxAsPublisher ); Flow . Publisher < T > monoAsPublisher = AdaptersToFlow . publisher ( mono ); Uni < T > uniFromMono = Uni . createFrom (). publisher ( monoAsPublisher ); When a Flux or Mono sends the completion event without having emitted any item, the resulting Uni emits null . When converting a Flux to Uni , the resulting Uni emits the first item. After that emission, it cancels the subscription to the Flux . Converting a Multi into a Flux or Mono # Converting a Multi into a Flux or a Mono uses the Reactive Streams interoperability: 1 2 3 4 Publisher < T > multiAsLegacyPublisher = AdaptersToReactiveStreams . publisher ( multi ); Flux < T > fluxFromMulti = Flux . from ( multiAsLegacyPublisher ); Mono < T > monoFromMulti = Mono . from ( multiAsLegacyPublisher ); Converting a Uni into a Flux or Mono # Converting a Uni into a Flux or a Mono requires a converter, as Uni does not implement Reactive Streams. 1 2 Flux < T > fluxFromUni = uni . convert (). with ( UniReactorConverters . toFlux ()); Mono < T > monoFromUni = uni . convert (). with ( UniReactorConverters . toMono ()); If the Uni emits null , it sends the completion event. Using converter instead of Reactive Streams # While Reactive Streams interoperability is convenient, Mutiny also provides converters to create Flux and Mono from Uni and Multi : 1 2 3 4 5 Mono < String > mono = uni . convert (). with ( UniReactorConverters . toMono ()); Flux < String > flux = uni . convert (). with ( UniReactorConverters . toFlux ()); Mono < String > mono = multi . convert (). with ( MultiReactorConverters . toMono ()); Flux < String > flux = multi . convert (). with ( MultiReactorConverters . toFlux ()); Integration with RX Java 3 # RxJava is another popular reactive programming library. It offers 5 types: Completable (no item), Single (one item), Maybe (0 or 1 item), Observable (multiple items), Flowable (multiple items, implements Reactive Stream Publisher ). To use the RxJava <-> Mutiny converters, add the following imports to your class: import io.smallrye.mutiny.converters.multi.MultiRx3Converters ; import io.smallrye.mutiny.converters.uni.UniRx3Converters ; Converting an Observable or a Flowable into a Multi # Both Observable and Flowable are item streams. However, Observable does not implement Publisher and so does not have back-pressure support. To create Multi from an Observable, you need a specific converter: 1 2 Multi < T > multiFromObservable = Multi . createFrom () . converter ( MultiRx3Converters . fromObservable (), observable ); Converting a Flowable is easier, as it\u2019s a Publisher : 1 2 3 Flow . Publisher < T > flowableAsPublisher = AdaptersToFlow . publisher ( flowable ); Multi < T > multiFromFlowable = Multi . createFrom (). publisher ( flowableAsPublisher ); Attention Like Reactor, RxJava still uses the legacy Reactive Streams APIs instead of java.util.concurrent.Flow , so you need to perform an adaptation. Converting a Completable, Single or Maybe into a Multi # To create a Multi from a Completable, Single or Maybe you need specific converters, as none of these types implement Reactive Streams. 1 2 3 4 5 6 7 8 Multi < Void > multiFromCompletable = Multi . createFrom () . converter ( MultiRx3Converters . fromCompletable (), completable ); Multi < T > multiFromSingle = Multi . createFrom () . converter ( MultiRx3Converters . fromSingle (), single ); Multi < T > multiFromMaybe = Multi . createFrom () . converter ( MultiRx3Converters . fromMaybe (), maybe ); Multi < T > multiFromEmptyMaybe = Multi . createFrom () . converter ( MultiRx3Converters . fromMaybe (), emptyMaybe ); Creating a Multi from a Completable always produces a Multi<Void> that only emits the completion or failure event. Creating a Multi from a Single produces a Multi . That Multi emits the item and then completes it. Creating a Multi from a Maybe produces a Multi . That Multi emits the item (if any) and then completes it. If the Maybe is empty, then the created Multi emits the completion event. When a Completable, Single, or Maybe emits a failure, then the resulting Multi emits that failure. Converting an Observable or a Flowable into a Uni # To create a Uni from an Observable, you need to use a specific converter: 1 2 Uni < T > uniFromObservable = Uni . createFrom (). converter ( UniRx3Converters . fromObservable (), observable ); The creation from a Flowable can be done using the Reactive Streams interoperability: 1 2 3 Flow . Publisher < T > flowableAsPublisher = AdaptersToFlow . publisher ( flowable ); Uni < T > uniFromFlowable = Uni . createFrom (). publisher ( flowableAsPublisher ); In both cases, it cancels the subscription to the Flowable or Observable after receiving the first item. If the Flowable or Observable completes without items, the Uni emits a null item. Converting a Completable, Single or Maybe into a Uni # To create a Uni from a Completable, Single, or Maybe , you need to use a specific converter: 1 2 3 4 5 6 7 8 Uni < Void > multiFromCompletable = Uni . createFrom () . converter ( UniRx3Converters . fromCompletable (), completable ); Uni < T > multiFromSingle = Uni . createFrom () . converter ( UniRx3Converters . fromSingle (), single ); Uni < T > multiFromMaybe = Uni . createFrom () . converter ( UniRx3Converters . fromMaybe (), maybe ); Uni < T > multiFromEmptyMaybe = Uni . createFrom () . converter ( UniRx3Converters . fromMaybe (), emptyMaybe ); Converting a Completable to a Uni always produces a Uni<Void>, that emits either null once the Completable completes or the failure if it fails. The Maybe to Uni conversion emits a null item if the Maybe completes without an item. Converting a Multi into a RX Java objects # The conversion from a Multi to the various RX Java objects is done using converters: 1 2 3 4 5 6 7 8 9 10 11 12 13 Completable completable = multi . convert () . with ( MultiRx3Converters . toCompletable ()); Single < Optional < T >> single = multi . convert () . with ( MultiRx3Converters . toSingle ()); Single < T > single2 = multi . convert () . with ( MultiRx3Converters . toSingle (). onEmptyThrow (() -> new Exception ( \"D'oh!\" ))); Maybe < T > maybe = multi . convert () . with ( MultiRx3Converters . toMaybe ()); Observable < T > observable = multi . convert () . with ( MultiRx3Converters . toObservable ()); Flowable < T > flowable = multi . convert () . with ( MultiRx3Converters . toFlowable ()); The creation of a Completable from a Multi discards all the items emitted by the Multi . It only forwards the completion or failure event. Converting a Multi into a Single returns a Single<Optional<T>>, as the Multi may complete without items. You can also produce a Single<T> and emit a failure event if the Multi completes without items. You can configure the thrown exception using onEmptyThrow. Tip You can also create a Flowable from a Multi using: Flowable.fromPublisher(multi) . Converting a Uni into a RX Java type # Similarly to the conversion from a Multi into an RX Type, converting a Uni requires a converter: 1 2 3 4 5 6 Completable completable = uni . convert (). with ( UniRx3Converters . toCompletable ()); Single < Optional < T >> single = uni . convert (). with ( UniRx3Converters . toSingle ()); Single < T > single2 = uni . convert (). with ( UniRx3Converters . toSingle (). failOnNull ()); Maybe < T > maybe = uni . convert (). with ( UniRx3Converters . toMaybe ()); Observable < T > observable = uni . convert (). with ( UniRx3Converters . toObservable ()); Flowable < T > flowable = uni . convert (). with ( UniRx3Converters . toFlowable ()); The creation of a Completable from a Uni discards the item and sends the completion signal after emission. Converting a Uni into a Single returns a Single<Optional<T>>, as the Uni may emit null. You can also produce a Single<T> and emits a failure event if the Uni sends null. Configure the failure to forward using failOnNull. The creation of a Maybe, Flowable, or an Observable from a Uni produces an empty Maybe, Flowable, or Observable if the Uni emits null. For Flowable and Observable, if the Uni emits a non-null item, that item is emitted, followed immediately by the completion signal.","title":"Using other reactive programming libraries"},{"location":"guides/converters/#using-other-reactive-programming-libraries","text":"You may need to integrate libraries exposing an API using other reactive programming libraries such as RX Java or Reactor. Mutiny has a built-in conversion mechanism to ease that integration.","title":"Using other reactive programming libraries"},{"location":"guides/converters/#picking-the-right-dependency","text":"You need to add another dependency to access the converters. Each artifact contains the converters for a specific reactive library. Pick the right one and add it to your project: Reactor RxJava 3 <!-- Mutiny <-> Reactor --> <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-reactor </artifactId> <version> 2.1.0 </version> </dependency> <!-- Mutiny <-> RX Java 3 --> <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-rxjava3 </artifactId> <version> 2.1.0 </version> </dependency>","title":"Picking the right dependency"},{"location":"guides/converters/#integration-with-project-reactor","text":"Project Reactor is a popular reactive programming library. It offers two types: Mono and Flux, both implementing Reactive Stream Publisher . To use the Reactor <-> Mutiny converter, add the following imports to your class: import io.smallrye.mutiny.converters.multi.MultiReactorConverters ; import io.smallrye.mutiny.converters.uni.UniReactorConverters ;","title":"Integration with Project Reactor"},{"location":"guides/converters/#converting-a-flux-or-a-mono-into-a-multi","text":"Both Flux and Mono implement Publisher . As a result, we can use the Reactive Streams interoperability to convert instances from Flux<T> and Mono<T> to Multi<T> : 1 2 3 4 5 Flow . Publisher < T > fluxAsPublisher = AdaptersToFlow . publisher ( flux ); Multi < T > multiFromFlux = Multi . createFrom (). publisher ( fluxAsPublisher ); Flow . Publisher < T > monoAsPublisher = AdaptersToFlow . publisher ( mono ); Multi < T > multiFromMono = Multi . createFrom (). publisher ( monoAsPublisher ); Attention Reactor still uses the legacy Reactive Streams APIs instead of java.util.concurrent.Flow , so you need to perform an adaptation. We recommend using the Mutiny Zero Flow Adapters library as in these examples (Maven coordinates io.smallrye.reactive:mutiny-zero-flow-adapters ).","title":"Converting a Flux or a Mono into a Multi"},{"location":"guides/converters/#converting-a-flux-or-a-mono-into-a-uni","text":"As you can create Uni from a Publisher , the same approach can be used to create Uni instances: 1 2 3 4 5 Flow . Publisher < T > fluxAsPublisher = AdaptersToFlow . publisher ( flux ); Uni < T > uniFromFlux = Uni . createFrom (). publisher ( fluxAsPublisher ); Flow . Publisher < T > monoAsPublisher = AdaptersToFlow . publisher ( mono ); Uni < T > uniFromMono = Uni . createFrom (). publisher ( monoAsPublisher ); When a Flux or Mono sends the completion event without having emitted any item, the resulting Uni emits null . When converting a Flux to Uni , the resulting Uni emits the first item. After that emission, it cancels the subscription to the Flux .","title":"Converting a Flux or a Mono into a Uni"},{"location":"guides/converters/#converting-a-multi-into-a-flux-or-mono","text":"Converting a Multi into a Flux or a Mono uses the Reactive Streams interoperability: 1 2 3 4 Publisher < T > multiAsLegacyPublisher = AdaptersToReactiveStreams . publisher ( multi ); Flux < T > fluxFromMulti = Flux . from ( multiAsLegacyPublisher ); Mono < T > monoFromMulti = Mono . from ( multiAsLegacyPublisher );","title":"Converting a Multi into a Flux or Mono"},{"location":"guides/converters/#converting-a-uni-into-a-flux-or-mono","text":"Converting a Uni into a Flux or a Mono requires a converter, as Uni does not implement Reactive Streams. 1 2 Flux < T > fluxFromUni = uni . convert (). with ( UniReactorConverters . toFlux ()); Mono < T > monoFromUni = uni . convert (). with ( UniReactorConverters . toMono ()); If the Uni emits null , it sends the completion event.","title":"Converting a Uni into a Flux or Mono"},{"location":"guides/converters/#using-converter-instead-of-reactive-streams","text":"While Reactive Streams interoperability is convenient, Mutiny also provides converters to create Flux and Mono from Uni and Multi : 1 2 3 4 5 Mono < String > mono = uni . convert (). with ( UniReactorConverters . toMono ()); Flux < String > flux = uni . convert (). with ( UniReactorConverters . toFlux ()); Mono < String > mono = multi . convert (). with ( MultiReactorConverters . toMono ()); Flux < String > flux = multi . convert (). with ( MultiReactorConverters . toFlux ());","title":"Using converter instead of Reactive Streams"},{"location":"guides/converters/#integration-with-rx-java-3","text":"RxJava is another popular reactive programming library. It offers 5 types: Completable (no item), Single (one item), Maybe (0 or 1 item), Observable (multiple items), Flowable (multiple items, implements Reactive Stream Publisher ). To use the RxJava <-> Mutiny converters, add the following imports to your class: import io.smallrye.mutiny.converters.multi.MultiRx3Converters ; import io.smallrye.mutiny.converters.uni.UniRx3Converters ;","title":"Integration with RX Java 3"},{"location":"guides/converters/#converting-an-observable-or-a-flowable-into-a-multi","text":"Both Observable and Flowable are item streams. However, Observable does not implement Publisher and so does not have back-pressure support. To create Multi from an Observable, you need a specific converter: 1 2 Multi < T > multiFromObservable = Multi . createFrom () . converter ( MultiRx3Converters . fromObservable (), observable ); Converting a Flowable is easier, as it\u2019s a Publisher : 1 2 3 Flow . Publisher < T > flowableAsPublisher = AdaptersToFlow . publisher ( flowable ); Multi < T > multiFromFlowable = Multi . createFrom (). publisher ( flowableAsPublisher ); Attention Like Reactor, RxJava still uses the legacy Reactive Streams APIs instead of java.util.concurrent.Flow , so you need to perform an adaptation.","title":"Converting an Observable or a Flowable into a Multi"},{"location":"guides/converters/#converting-a-completable-single-or-maybe-into-a-multi","text":"To create a Multi from a Completable, Single or Maybe you need specific converters, as none of these types implement Reactive Streams. 1 2 3 4 5 6 7 8 Multi < Void > multiFromCompletable = Multi . createFrom () . converter ( MultiRx3Converters . fromCompletable (), completable ); Multi < T > multiFromSingle = Multi . createFrom () . converter ( MultiRx3Converters . fromSingle (), single ); Multi < T > multiFromMaybe = Multi . createFrom () . converter ( MultiRx3Converters . fromMaybe (), maybe ); Multi < T > multiFromEmptyMaybe = Multi . createFrom () . converter ( MultiRx3Converters . fromMaybe (), emptyMaybe ); Creating a Multi from a Completable always produces a Multi<Void> that only emits the completion or failure event. Creating a Multi from a Single produces a Multi . That Multi emits the item and then completes it. Creating a Multi from a Maybe produces a Multi . That Multi emits the item (if any) and then completes it. If the Maybe is empty, then the created Multi emits the completion event. When a Completable, Single, or Maybe emits a failure, then the resulting Multi emits that failure.","title":"Converting a Completable, Single or Maybe into a Multi"},{"location":"guides/converters/#converting-an-observable-or-a-flowable-into-a-uni","text":"To create a Uni from an Observable, you need to use a specific converter: 1 2 Uni < T > uniFromObservable = Uni . createFrom (). converter ( UniRx3Converters . fromObservable (), observable ); The creation from a Flowable can be done using the Reactive Streams interoperability: 1 2 3 Flow . Publisher < T > flowableAsPublisher = AdaptersToFlow . publisher ( flowable ); Uni < T > uniFromFlowable = Uni . createFrom (). publisher ( flowableAsPublisher ); In both cases, it cancels the subscription to the Flowable or Observable after receiving the first item. If the Flowable or Observable completes without items, the Uni emits a null item.","title":"Converting an Observable or a Flowable into a Uni"},{"location":"guides/converters/#converting-a-completable-single-or-maybe-into-a-uni","text":"To create a Uni from a Completable, Single, or Maybe , you need to use a specific converter: 1 2 3 4 5 6 7 8 Uni < Void > multiFromCompletable = Uni . createFrom () . converter ( UniRx3Converters . fromCompletable (), completable ); Uni < T > multiFromSingle = Uni . createFrom () . converter ( UniRx3Converters . fromSingle (), single ); Uni < T > multiFromMaybe = Uni . createFrom () . converter ( UniRx3Converters . fromMaybe (), maybe ); Uni < T > multiFromEmptyMaybe = Uni . createFrom () . converter ( UniRx3Converters . fromMaybe (), emptyMaybe ); Converting a Completable to a Uni always produces a Uni<Void>, that emits either null once the Completable completes or the failure if it fails. The Maybe to Uni conversion emits a null item if the Maybe completes without an item.","title":"Converting a Completable, Single or Maybe into a Uni"},{"location":"guides/converters/#converting-a-multi-into-a-rx-java-objects","text":"The conversion from a Multi to the various RX Java objects is done using converters: 1 2 3 4 5 6 7 8 9 10 11 12 13 Completable completable = multi . convert () . with ( MultiRx3Converters . toCompletable ()); Single < Optional < T >> single = multi . convert () . with ( MultiRx3Converters . toSingle ()); Single < T > single2 = multi . convert () . with ( MultiRx3Converters . toSingle (). onEmptyThrow (() -> new Exception ( \"D'oh!\" ))); Maybe < T > maybe = multi . convert () . with ( MultiRx3Converters . toMaybe ()); Observable < T > observable = multi . convert () . with ( MultiRx3Converters . toObservable ()); Flowable < T > flowable = multi . convert () . with ( MultiRx3Converters . toFlowable ()); The creation of a Completable from a Multi discards all the items emitted by the Multi . It only forwards the completion or failure event. Converting a Multi into a Single returns a Single<Optional<T>>, as the Multi may complete without items. You can also produce a Single<T> and emit a failure event if the Multi completes without items. You can configure the thrown exception using onEmptyThrow. Tip You can also create a Flowable from a Multi using: Flowable.fromPublisher(multi) .","title":"Converting a Multi into a RX Java objects"},{"location":"guides/converters/#converting-a-uni-into-a-rx-java-type","text":"Similarly to the conversion from a Multi into an RX Type, converting a Uni requires a converter: 1 2 3 4 5 6 Completable completable = uni . convert (). with ( UniRx3Converters . toCompletable ()); Single < Optional < T >> single = uni . convert (). with ( UniRx3Converters . toSingle ()); Single < T > single2 = uni . convert (). with ( UniRx3Converters . toSingle (). failOnNull ()); Maybe < T > maybe = uni . convert (). with ( UniRx3Converters . toMaybe ()); Observable < T > observable = uni . convert (). with ( UniRx3Converters . toObservable ()); Flowable < T > flowable = uni . convert (). with ( UniRx3Converters . toFlowable ()); The creation of a Completable from a Uni discards the item and sends the completion signal after emission. Converting a Uni into a Single returns a Single<Optional<T>>, as the Uni may emit null. You can also produce a Single<T> and emits a failure event if the Uni sends null. Configure the failure to forward using failOnNull. The creation of a Maybe, Flowable, or an Observable from a Uni produces an empty Maybe, Flowable, or Observable if the Uni emits null. For Flowable and Observable, if the Uni emits a non-null item, that item is emitted, followed immediately by the completion signal.","title":"Converting a Uni into a RX Java type"},{"location":"guides/custom-operators/","tags":["guide","advanced"],"text":"Can I have custom operators? # Yes, but please write operators responsibly! Both Uni and Multi support custom operators using the plug operator. Here is an example where we use a custom Multi operator that randomly drops items: 1 2 3 4 Multi . createFrom () . range ( 1 , 101 ) . plug ( RandomDrop :: new ) . subscribe (). with ( System . out :: println ); with the operator defined as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class RandomDrop < T > extends AbstractMultiOperator < T , T > { public RandomDrop ( Multi <? extends T > upstream ) { super ( upstream ); } @Override public void subscribe ( MultiSubscriber <? super T > downstream ) { upstream . subscribe (). withSubscriber ( new DropProcessor ( downstream )); } private class DropProcessor extends MultiOperatorProcessor < T , T > { DropProcessor ( MultiSubscriber <? super T > downstream ) { super ( downstream ); } @Override public void onItem ( T item ) { if ( ThreadLocalRandom . current (). nextBoolean ()) { super . onItem ( item ); } } } } Caution Custom operators are an advanced feature: when possible please use the existing operators and use helpers such as stage to write readable code. In the case of custom Multi operators it is wise to test them against the Reactive Streams TCK .","title":"Can I have custom operators?"},{"location":"guides/custom-operators/#can-i-have-custom-operators","text":"Yes, but please write operators responsibly! Both Uni and Multi support custom operators using the plug operator. Here is an example where we use a custom Multi operator that randomly drops items: 1 2 3 4 Multi . createFrom () . range ( 1 , 101 ) . plug ( RandomDrop :: new ) . subscribe (). with ( System . out :: println ); with the operator defined as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class RandomDrop < T > extends AbstractMultiOperator < T , T > { public RandomDrop ( Multi <? extends T > upstream ) { super ( upstream ); } @Override public void subscribe ( MultiSubscriber <? super T > downstream ) { upstream . subscribe (). withSubscriber ( new DropProcessor ( downstream )); } private class DropProcessor extends MultiOperatorProcessor < T , T > { DropProcessor ( MultiSubscriber <? super T > downstream ) { super ( downstream ); } @Override public void onItem ( T item ) { if ( ThreadLocalRandom . current (). nextBoolean ()) { super . onItem ( item ); } } } } Caution Custom operators are an advanced feature: when possible please use the existing operators and use helpers such as stage to write readable code. In the case of custom Multi operators it is wise to test them against the Reactive Streams TCK .","title":"Can I have custom operators?"},{"location":"guides/delaying-events/","tags":["guide","intermediate"],"text":"How to delay events? # Delaying Uni\u2019s item # When you have a Uni , you can delay the item emission using onItem().delayIt().by(...) : 1 2 Uni < String > delayed = Uni . createFrom (). item ( \"hello\" ) . onItem (). delayIt (). by ( Duration . ofMillis ( 10 )); You pass a duration. When the item is received, it waits for that duration before propagating it to the downstream consumer. You can also delay the item\u2019s emission based on another companion Uni : 1 2 3 4 Uni < String > delayed = Uni . createFrom (). item ( \"hello\" ) // The write method returns a Uni completed // when the operation is done. . onItem (). delayIt (). until ( this :: write ); The item is propagated downstream when the Uni returned by the function emits an item (possibly null ). If the function emits a failure (or throws an exception), this failure is propagated downstream. Throttling a Multi # Multi does not have a delayIt operator because applying the same delay to all items is rarely what you want to do. However, there are several ways to apply a delay in a Multi . First, you can use the onItem().call() , which delays the emission until the Uni produced the call emits an item. For example, the following snippet delays all the items by 10 ms: 1 2 3 4 5 Multi < Integer > delayed = multi . onItem (). call ( i -> // Delay the emission until the returned uni emits its item Uni . createFrom (). nullItem (). onItem (). delayIt (). by ( Duration . ofMillis ( 10 )) ); In general, you don\u2019t want to apply the same delay to all the items. You can combine call with a random delay as follows: 1 2 3 4 5 6 Random random = new Random (); Multi < Integer > delayed = Multi . createFrom (). items ( 1 , 2 , 3 , 4 , 5 ) . onItem (). call ( i -> { Duration delay = Duration . ofMillis ( random . nextInt ( 100 ) + 1 ); return Uni . createFrom (). nullItem (). onItem (). delayIt (). by ( delay ); }); Finally, you may want to throttle the items. For example, you can introduce a (minimum) one-second delay between each item. To achieve this, combine Multi.createFrom().ticks() and the multi to throttled: 1 2 3 4 5 // Introduce a one second delay between each item Multi < Long > ticks = Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . onOverflow (). drop (); Multi < Integer > delayed = Multi . createBy (). combining (). streams ( ticks , multi ) . using (( x , item ) -> item ); Tip The onOverflow().drop() is used to avoid the ticks to fail if the other stream ( multi ) is too slow. Delaying other types of events # We have looked at how to delay items, but you may need to delay other events, such as subscription or failure. For these, use the call approach, and return a Uni that delay the event\u2019s propagation.","title":"How to delay events?"},{"location":"guides/delaying-events/#how-to-delay-events","text":"","title":"How to delay events?"},{"location":"guides/delaying-events/#delaying-unis-item","text":"When you have a Uni , you can delay the item emission using onItem().delayIt().by(...) : 1 2 Uni < String > delayed = Uni . createFrom (). item ( \"hello\" ) . onItem (). delayIt (). by ( Duration . ofMillis ( 10 )); You pass a duration. When the item is received, it waits for that duration before propagating it to the downstream consumer. You can also delay the item\u2019s emission based on another companion Uni : 1 2 3 4 Uni < String > delayed = Uni . createFrom (). item ( \"hello\" ) // The write method returns a Uni completed // when the operation is done. . onItem (). delayIt (). until ( this :: write ); The item is propagated downstream when the Uni returned by the function emits an item (possibly null ). If the function emits a failure (or throws an exception), this failure is propagated downstream.","title":"Delaying Uni's item"},{"location":"guides/delaying-events/#throttling-a-multi","text":"Multi does not have a delayIt operator because applying the same delay to all items is rarely what you want to do. However, there are several ways to apply a delay in a Multi . First, you can use the onItem().call() , which delays the emission until the Uni produced the call emits an item. For example, the following snippet delays all the items by 10 ms: 1 2 3 4 5 Multi < Integer > delayed = multi . onItem (). call ( i -> // Delay the emission until the returned uni emits its item Uni . createFrom (). nullItem (). onItem (). delayIt (). by ( Duration . ofMillis ( 10 )) ); In general, you don\u2019t want to apply the same delay to all the items. You can combine call with a random delay as follows: 1 2 3 4 5 6 Random random = new Random (); Multi < Integer > delayed = Multi . createFrom (). items ( 1 , 2 , 3 , 4 , 5 ) . onItem (). call ( i -> { Duration delay = Duration . ofMillis ( random . nextInt ( 100 ) + 1 ); return Uni . createFrom (). nullItem (). onItem (). delayIt (). by ( delay ); }); Finally, you may want to throttle the items. For example, you can introduce a (minimum) one-second delay between each item. To achieve this, combine Multi.createFrom().ticks() and the multi to throttled: 1 2 3 4 5 // Introduce a one second delay between each item Multi < Long > ticks = Multi . createFrom (). ticks (). every ( Duration . ofSeconds ( 1 )) . onOverflow (). drop (); Multi < Integer > delayed = Multi . createBy (). combining (). streams ( ticks , multi ) . using (( x , item ) -> item ); Tip The onOverflow().drop() is used to avoid the ticks to fail if the other stream ( multi ) is too slow.","title":"Throttling a Multi"},{"location":"guides/delaying-events/#delaying-other-types-of-events","text":"We have looked at how to delay items, but you may need to delay other events, such as subscription or failure. For these, use the call approach, and return a Uni that delay the event\u2019s propagation.","title":"Delaying other types of events"},{"location":"guides/dropped-exceptions/","tags":["guide","advanced"],"text":"How to deal with dropped exceptions? # There are a few corner cases where Mutiny cannot propagate an exception to a Uni or a Multi subscriber. Consider the following example: 1 2 3 4 5 6 Cancellable cancellable = Uni . createFrom () . emitter ( this :: emitter ) . onCancellation (). call (() -> Uni . createFrom (). failure ( new IOException ( \"boom\" ))) . subscribe (). with ( this :: onItem , this :: onFailure ); cancellable . cancel (); The onCancellation().call(...) method is called when the Uni subscription is cancelled. The returned Uni is failed with a IOException , but since the subscription itself has been cancelled then there is no way to catch the exception. By default Mutiny reports such dropped exceptions to the standard error stream along with the corresponding stack trace. You can change how these exceptions are handled using Infrastructure.setDroppedExceptionHandler . The following logs dropped exceptions to a logger: 1 2 3 Infrastructure . setDroppedExceptionHandler ( err -> log ( Level . SEVERE , \"Mutiny dropped exception\" , err ) );","title":"How to deal with dropped exceptions?"},{"location":"guides/dropped-exceptions/#how-to-deal-with-dropped-exceptions","text":"There are a few corner cases where Mutiny cannot propagate an exception to a Uni or a Multi subscriber. Consider the following example: 1 2 3 4 5 6 Cancellable cancellable = Uni . createFrom () . emitter ( this :: emitter ) . onCancellation (). call (() -> Uni . createFrom (). failure ( new IOException ( \"boom\" ))) . subscribe (). with ( this :: onItem , this :: onFailure ); cancellable . cancel (); The onCancellation().call(...) method is called when the Uni subscription is cancelled. The returned Uni is failed with a IOException , but since the subscription itself has been cancelled then there is no way to catch the exception. By default Mutiny reports such dropped exceptions to the standard error stream along with the corresponding stack trace. You can change how these exceptions are handled using Infrastructure.setDroppedExceptionHandler . The following logs dropped exceptions to a logger: 1 2 3 Infrastructure . setDroppedExceptionHandler ( err -> log ( Level . SEVERE , \"Mutiny dropped exception\" , err ) );","title":"How to deal with dropped exceptions?"},{"location":"guides/eliminate-duplicates-and-repetitions/","tags":["guide","beginner"],"text":"Eliminate duplicates and repetitions # When observing a Multi , you may see duplicated items or repetitions. The multi.select() and multi.skip() groups provide methods to only select distinct items or drop repetitions. Selecting distinct # The .select().distinct() operator removes all the duplicates. As a result, the downstream only contains distinct items: 1 2 3 4 List < Integer > list = multi . select (). distinct () . collect (). asList () . await (). indefinitely (); If you have a stream emitting the {1, 1, 2, 3, 4, 5, 5, 6, 1, 4, 4} items, then applying .select().distinct() on such a stream produces: {1, 2, 3, 4, 5, 6} . Important The operator keeps a reference on all the emitted items, and so, it could lead to memory issues if the stream contains too many distinct items. Tip By default, select().distinct() uses the hashCode method from the item\u2019s class. You can pass a custom comparator for more advanced checks. Skipping repetitions # The .skip().repetitions() operator removes subsequent repetitions of an item: 1 2 3 4 List < Integer > list2 = multi . skip (). repetitions () . collect (). asList () . await (). indefinitely (); If you have a stream emitting the {1, 1, 2, 3, 4, 5, 5, 6, 1, 4, 4} items, then applying .skip().repetitions() on such a stream produces: {1, 2, 3, 4, 5, 6, 1, 4} . Unlike .select().distinct() , you can use this operator on large or infinite streams. Tip By default, skip().repetitions() uses the equals method from the item\u2019s class. You can pass a custom comparator for more advanced checks.","title":"Eliminate duplicates and repetitions"},{"location":"guides/eliminate-duplicates-and-repetitions/#eliminate-duplicates-and-repetitions","text":"When observing a Multi , you may see duplicated items or repetitions. The multi.select() and multi.skip() groups provide methods to only select distinct items or drop repetitions.","title":"Eliminate duplicates and repetitions"},{"location":"guides/eliminate-duplicates-and-repetitions/#selecting-distinct","text":"The .select().distinct() operator removes all the duplicates. As a result, the downstream only contains distinct items: 1 2 3 4 List < Integer > list = multi . select (). distinct () . collect (). asList () . await (). indefinitely (); If you have a stream emitting the {1, 1, 2, 3, 4, 5, 5, 6, 1, 4, 4} items, then applying .select().distinct() on such a stream produces: {1, 2, 3, 4, 5, 6} . Important The operator keeps a reference on all the emitted items, and so, it could lead to memory issues if the stream contains too many distinct items. Tip By default, select().distinct() uses the hashCode method from the item\u2019s class. You can pass a custom comparator for more advanced checks.","title":"Selecting distinct"},{"location":"guides/eliminate-duplicates-and-repetitions/#skipping-repetitions","text":"The .skip().repetitions() operator removes subsequent repetitions of an item: 1 2 3 4 List < Integer > list2 = multi . skip (). repetitions () . collect (). asList () . await (). indefinitely (); If you have a stream emitting the {1, 1, 2, 3, 4, 5, 5, 6, 1, 4, 4} items, then applying .skip().repetitions() on such a stream produces: {1, 2, 3, 4, 5, 6, 1, 4} . Unlike .select().distinct() , you can use this operator on large or infinite streams. Tip By default, skip().repetitions() uses the equals method from the item\u2019s class. You can pass a custom comparator for more advanced checks.","title":"Skipping repetitions"},{"location":"guides/emission-threads/","tags":["guide","intermediate"],"text":"How to change the emission thread? # Except indicated otherwise, Mutiny invokes the next stage using the thread emitting the event from upstream. So, in the following code, the transform stage is invoked from the thread emitting the event. 1 2 3 4 5 6 7 8 9 10 Uni < String > uni = Uni . createFrom (). < String > emitter ( emitter -> new Thread (() -> emitter . complete ( \"hello from \" + Thread . currentThread (). getName ()) ). start () ) . onItem (). transform ( item -> { // Called on the emission thread. return item . toUpperCase (); }); You can switch to another thread using the emitOn operator. The emitOn operator lets you switch the thread used to dispatch (upstream -> downstream) events, so items, failure and completion events. Just pass the executor you want to use. 1 2 3 4 5 6 7 8 9 10 11 12 String res0 = uni . emitOn ( executor ) . onItem () . invoke ( s -> System . out . println ( \"Received item `\" + s + \"` on thread: \" + Thread . currentThread (). getName ())) . await (). indefinitely (); String res1 = multi . emitOn ( executor ) . onItem () . invoke ( s -> System . out . println ( \"Received item `\" + s + \"` on thread: \" + Thread . currentThread (). getName ())) . collect (). first () . await (). indefinitely (); Note You cannot pass a specific thread, but you can implement a simple Executor dispatching on that specific thread, or use a single threaded executor . Warning Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.","title":"How to change the emission thread?"},{"location":"guides/emission-threads/#how-to-change-the-emission-thread","text":"Except indicated otherwise, Mutiny invokes the next stage using the thread emitting the event from upstream. So, in the following code, the transform stage is invoked from the thread emitting the event. 1 2 3 4 5 6 7 8 9 10 Uni < String > uni = Uni . createFrom (). < String > emitter ( emitter -> new Thread (() -> emitter . complete ( \"hello from \" + Thread . currentThread (). getName ()) ). start () ) . onItem (). transform ( item -> { // Called on the emission thread. return item . toUpperCase (); }); You can switch to another thread using the emitOn operator. The emitOn operator lets you switch the thread used to dispatch (upstream -> downstream) events, so items, failure and completion events. Just pass the executor you want to use. 1 2 3 4 5 6 7 8 9 10 11 12 String res0 = uni . emitOn ( executor ) . onItem () . invoke ( s -> System . out . println ( \"Received item `\" + s + \"` on thread: \" + Thread . currentThread (). getName ())) . await (). indefinitely (); String res1 = multi . emitOn ( executor ) . onItem () . invoke ( s -> System . out . println ( \"Received item `\" + s + \"` on thread: \" + Thread . currentThread (). getName ())) . collect (). first () . await (). indefinitely (); Note You cannot pass a specific thread, but you can implement a simple Executor dispatching on that specific thread, or use a single threaded executor . Warning Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.","title":"How to change the emission thread?"},{"location":"guides/emit-on-vs-run-subscription-on/","tags":["guide","intermediate"],"text":"What is the difference between emitOn and runSubscriptionOn? # The emitOn and runSubscriptionOn are 2 operators influencing on which threads the event are dispatched. However, they target different types of events and different directions. The case of emitOn # emitOn takes events coming from upstream (items, completion, failure) and replays them downstream on a thread from the given executor. Consequently, it affects where the subsequent operators execute (until another emitOn is used): 1 2 3 4 5 6 7 8 Multi . createFrom (). items ( this :: retrieveItemsFromSource ) . emitOn ( executor ) . onItem (). transform ( this :: applySomeOperation ) . subscribe (). with ( item -> System . out . println ( \"Item: \" + item ), Throwable :: printStackTrace , () -> completed . set ( true ) ); The previous code produces the following sequence: sequenceDiagram autonumber participant M as Multi participant O as emitOn(executor) participant D as Subscriber M->>O: onItem(1) Note right of M: On caller thread O->>D: onItem(1) Note right of O: On executor thread Warning Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently. The case of runSubscriptionOn # runSubscriptionOn applies to the subscription process. It requests the upstream to run its subscription (call of the subscribe method on its own upstream) on a thread from the given executor: 1 2 3 4 5 6 7 8 9 10 11 Multi . createFrom (). items (() -> { // called on a thread from the executor return retrieveItemsFromSource (); }) . onItem (). transform ( this :: applySomeOperation ) . runSubscriptionOn ( executor ) . subscribe (). with ( item -> System . out . println ( \"Item: \" + item ), Throwable :: printStackTrace , () -> completed . set ( true ) ); So, if we consider the previous code snippet, it produces the following sequence: sequenceDiagram autonumber participant M as Multi participant O as runSubscriptionOn(executor) participant D as Subscriber D->>O: subscribe Note right of O: on Caller thread O->>M: subscribe Note right of M: On executor thread","title":"What is the difference between emitOn and runSubscriptionOn?"},{"location":"guides/emit-on-vs-run-subscription-on/#what-is-the-difference-between-emiton-and-runsubscriptionon","text":"The emitOn and runSubscriptionOn are 2 operators influencing on which threads the event are dispatched. However, they target different types of events and different directions.","title":"What is the difference between emitOn and runSubscriptionOn?"},{"location":"guides/emit-on-vs-run-subscription-on/#the-case-of-emiton","text":"emitOn takes events coming from upstream (items, completion, failure) and replays them downstream on a thread from the given executor. Consequently, it affects where the subsequent operators execute (until another emitOn is used): 1 2 3 4 5 6 7 8 Multi . createFrom (). items ( this :: retrieveItemsFromSource ) . emitOn ( executor ) . onItem (). transform ( this :: applySomeOperation ) . subscribe (). with ( item -> System . out . println ( \"Item: \" + item ), Throwable :: printStackTrace , () -> completed . set ( true ) ); The previous code produces the following sequence: sequenceDiagram autonumber participant M as Multi participant O as emitOn(executor) participant D as Subscriber M->>O: onItem(1) Note right of M: On caller thread O->>D: onItem(1) Note right of O: On executor thread Warning Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.","title":"The case of emitOn"},{"location":"guides/emit-on-vs-run-subscription-on/#the-case-of-runsubscriptionon","text":"runSubscriptionOn applies to the subscription process. It requests the upstream to run its subscription (call of the subscribe method on its own upstream) on a thread from the given executor: 1 2 3 4 5 6 7 8 9 10 11 Multi . createFrom (). items (() -> { // called on a thread from the executor return retrieveItemsFromSource (); }) . onItem (). transform ( this :: applySomeOperation ) . runSubscriptionOn ( executor ) . subscribe (). with ( item -> System . out . println ( \"Item: \" + item ), Throwable :: printStackTrace , () -> completed . set ( true ) ); So, if we consider the previous code snippet, it produces the following sequence: sequenceDiagram autonumber participant M as Multi participant O as runSubscriptionOn(executor) participant D as Subscriber D->>O: subscribe Note right of O: on Caller thread O->>M: subscribe Note right of M: On executor thread","title":"The case of runSubscriptionOn"},{"location":"guides/filtering-items/","tags":["guide","beginner"],"text":"Filtering items from Multi # When observing a Multi , you may not want to forward all the received items to the downstream. Use the multi.select() group to select items. 1 2 3 4 List < Integer > list = multi . select (). where ( i -> i > 6 ) . collect (). asList () . await (). indefinitely (); To select items passing a given predicate, use multi.select().where(predicate) : where accepts a predicate called for each item. If the predicate returns true , the item propagated downstream. Otherwise, it drops the item. The predicate passed to where is synchronous. The when method provides an asynchronous version: 1 2 3 4 List < Integer > list2 = multi . select (). when ( i -> Uni . createFrom (). item ( i > 6 )) . collect (). asList () . await (). indefinitely (); when accepts a function called for each item. Unlike where where the predicate returns a boolean synchronously, the function returns a Uni<Boolean> . It forwards the item downstream if the uni produced by the function emits true . Otherwise, it drops the item.","title":"Filtering items from Multi"},{"location":"guides/filtering-items/#filtering-items-from-multi","text":"When observing a Multi , you may not want to forward all the received items to the downstream. Use the multi.select() group to select items. 1 2 3 4 List < Integer > list = multi . select (). where ( i -> i > 6 ) . collect (). asList () . await (). indefinitely (); To select items passing a given predicate, use multi.select().where(predicate) : where accepts a predicate called for each item. If the predicate returns true , the item propagated downstream. Otherwise, it drops the item. The predicate passed to where is synchronous. The when method provides an asynchronous version: 1 2 3 4 List < Integer > list2 = multi . select (). when ( i -> Uni . createFrom (). item ( i > 6 )) . collect (). asList () . await (). indefinitely (); when accepts a function called for each item. Unlike where where the predicate returns a boolean synchronously, the function returns a Uni<Boolean> . It forwards the item downstream if the uni produced by the function emits true . Otherwise, it drops the item.","title":"Filtering items from Multi"},{"location":"guides/framework-integration/","tags":["guide","advanced"],"text":"How can I integrate Mutiny with my framework? # Sometimes, Mutiny needs to execute tasks on other threads, such as monitoring time or delaying actions. Most operators relying on such capacity let you pass either a ScheduledExecutorService or an ExecutorService . By default, Mutiny uses the a cached thread pool as default executor, that creates new threads as needed, but reuse previously constructed threads when they are available. A ScheduledExecutorService is also created but delegates the execution of the delayed/scheduled tasks to the default executor. In the case you want to integrate Mutiny with a thread pool managed by a platform, you can configure it using Infrastructure.setDefaultExecutor() method: 1 2 3 4 5 6 7 Uni < Integer > uni1 = Uni . createFrom (). item ( 1 ) . emitOn ( Infrastructure . getDefaultExecutor ()); Uni < Integer > uni2 = Uni . createFrom (). item ( 2 ) . onItem (). delayIt () . onExecutor ( Infrastructure . getDefaultWorkerPool ()) . by ( Duration . ofMillis ( 10 )); You can configure the default executor using the Infrastructure.setDefaultExecutor method: 1 Infrastructure . setDefaultExecutor ( executor ); Tip If you are using Quarkus, the default executor is already configured to use the Quarkus worker thread pool. Logging is also configured correctly.","title":"How can I integrate Mutiny with my framework?"},{"location":"guides/framework-integration/#how-can-i-integrate-mutiny-with-my-framework","text":"Sometimes, Mutiny needs to execute tasks on other threads, such as monitoring time or delaying actions. Most operators relying on such capacity let you pass either a ScheduledExecutorService or an ExecutorService . By default, Mutiny uses the a cached thread pool as default executor, that creates new threads as needed, but reuse previously constructed threads when they are available. A ScheduledExecutorService is also created but delegates the execution of the delayed/scheduled tasks to the default executor. In the case you want to integrate Mutiny with a thread pool managed by a platform, you can configure it using Infrastructure.setDefaultExecutor() method: 1 2 3 4 5 6 7 Uni < Integer > uni1 = Uni . createFrom (). item ( 1 ) . emitOn ( Infrastructure . getDefaultExecutor ()); Uni < Integer > uni2 = Uni . createFrom (). item ( 2 ) . onItem (). delayIt () . onExecutor ( Infrastructure . getDefaultWorkerPool ()) . by ( Duration . ofMillis ( 10 )); You can configure the default executor using the Infrastructure.setDefaultExecutor method: 1 Infrastructure . setDefaultExecutor ( executor ); Tip If you are using Quarkus, the default executor is already configured to use the Quarkus worker thread pool. Logging is also configured correctly.","title":"How can I integrate Mutiny with my framework?"},{"location":"guides/handling-null/","tags":["guide","beginner"],"text":"How to handle null? # The Uni type can emit null as item. While there are mixed feelings about null , it\u2019s part of the Java language and so handled in the Uni type. Important Multi does not support null items as it would break the compatibility with the Reactive Streams protocol. Emitting null is convenient when returning Uni<Void> . However, the downstream must expect null as item. Thus, Uni provides specific methods to handle null item. uni.onItem().ifNull() lets you decide what you want to do when the received item is null : 1 2 3 uni . onItem (). ifNull (). continueWith ( \"hello\" ); uni . onItem (). ifNull (). switchTo (() -> Uni . createFrom (). item ( \"hello\" )); uni . onItem (). ifNull (). failWith (() -> new Exception ( \"Boom!\" )); A symmetric group of methods is also available with ifNotNull which let you handle the case where the item is not null : 1 2 3 uni . onItem (). ifNotNull (). transform ( String :: toUpperCase ) . onItem (). ifNull (). continueWith ( \"yolo!\" ); Important While supported, emitting null should be avoided except for Uni<Void> .","title":"How to handle null?"},{"location":"guides/handling-null/#how-to-handle-null","text":"The Uni type can emit null as item. While there are mixed feelings about null , it\u2019s part of the Java language and so handled in the Uni type. Important Multi does not support null items as it would break the compatibility with the Reactive Streams protocol. Emitting null is convenient when returning Uni<Void> . However, the downstream must expect null as item. Thus, Uni provides specific methods to handle null item. uni.onItem().ifNull() lets you decide what you want to do when the received item is null : 1 2 3 uni . onItem (). ifNull (). continueWith ( \"hello\" ); uni . onItem (). ifNull (). switchTo (() -> Uni . createFrom (). item ( \"hello\" )); uni . onItem (). ifNull (). failWith (() -> new Exception ( \"Boom!\" )); A symmetric group of methods is also available with ifNotNull which let you handle the case where the item is not null : 1 2 3 uni . onItem (). ifNotNull (). transform ( String :: toUpperCase ) . onItem (). ifNull (). continueWith ( \"yolo!\" ); Important While supported, emitting null should be avoided except for Uni<Void> .","title":"How to handle null?"},{"location":"guides/handling-timeouts/","tags":["guide","intermediate"],"text":"How to handle timeouts? # Unis are often used to represent asynchronous operations, like making an HTTP call. So, it\u2019s not rare to need to add a timeout or a deadline on this kind of operation. If we don\u2019t get a response (receive an item in the Mutiny lingo) before that deadline, we consider that the operation failed. We can then recover from this failure by using a fallback value, retrying, or any other failure handling strategy. To configure a timeout use Uni.ifNoItem().after(Duration) : 1 2 3 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )) . recoverWithItem ( \"some fallback item\" ); When the deadline is reached, you can do various actions. First you can simply fail: 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). fail (); A TimeoutException is propagated in this case. So you can handle it specifically in the downstream: 1 2 3 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). fail () . onFailure ( TimeoutException . class ). recoverWithItem ( \"we got a timeout\" ); You can also pass a custom exception: 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). failWith (() -> new ServiceUnavailableException ()); Failing and recovering might be inconvenient. So, you can pass a fallback item or Uni directly: 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). recoverWithItem (() -> \"fallback\" ); 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). recoverWithUni (() -> someFallbackUni ());","title":"How to handle timeouts?"},{"location":"guides/handling-timeouts/#how-to-handle-timeouts","text":"Unis are often used to represent asynchronous operations, like making an HTTP call. So, it\u2019s not rare to need to add a timeout or a deadline on this kind of operation. If we don\u2019t get a response (receive an item in the Mutiny lingo) before that deadline, we consider that the operation failed. We can then recover from this failure by using a fallback value, retrying, or any other failure handling strategy. To configure a timeout use Uni.ifNoItem().after(Duration) : 1 2 3 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )) . recoverWithItem ( \"some fallback item\" ); When the deadline is reached, you can do various actions. First you can simply fail: 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). fail (); A TimeoutException is propagated in this case. So you can handle it specifically in the downstream: 1 2 3 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). fail () . onFailure ( TimeoutException . class ). recoverWithItem ( \"we got a timeout\" ); You can also pass a custom exception: 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). failWith (() -> new ServiceUnavailableException ()); Failing and recovering might be inconvenient. So, you can pass a fallback item or Uni directly: 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). recoverWithItem (() -> \"fallback\" ); 1 2 Uni < String > uniWithTimeout = uni . ifNoItem (). after ( Duration . ofMillis ( 100 )). recoverWithUni (() -> someFallbackUni ());","title":"How to handle timeouts?"},{"location":"guides/hot-streams/","tags":["guide","advanced"],"text":"Hot streams # In a cold stream, the stream is created when one subscriber subscribes to the stream. So, if no one subscribes, the actual stream is not created, saving resources (that would be wasted because nobody is interested in the items). In a hot stream, the stream exists before subscribers subscribe. The stream emits items even if no subscribers observe the stream. If there are no subscribers, the items are just dropped. Subscribers only get items emitted after their subscription, meaning that any previous items would not be received. To create a hot stream, you can use io.smallrye.mutiny.operators.multi.processors.BroadcastProcessor that: drops items if no subscribers are present, forwards items to the set of observing subscribers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 BroadcastProcessor < String > processor = BroadcastProcessor . create (); Multi < String > multi = processor . onItem (). transform ( String :: toUpperCase ) . onFailure (). recoverWithItem ( \"d'oh\" ); new Thread (() -> { for ( int i = 0 ; i < 1000 ; i ++ ) { processor . onNext ( Integer . toString ( i )); } processor . onComplete (); }). start (); // Subscribers can subscribe at any time. // They will only receive items emitted after their subscription. // If the source is already terminated (by a completion or a failure signal) // the subscriber receives this signal. Note that the BroadcastProcessor subscribes to the hot source aggressively and without back-pressure. However, the BroadcastProcessor enforces the back-pressure protocol per subscriber. If a subscriber is not ready to handle an item emitted by the hot source, an io.smallrye.mutiny.subscription.BackPressureFailure is forwarded to this subscriber.","title":"Hot streams"},{"location":"guides/hot-streams/#hot-streams","text":"In a cold stream, the stream is created when one subscriber subscribes to the stream. So, if no one subscribes, the actual stream is not created, saving resources (that would be wasted because nobody is interested in the items). In a hot stream, the stream exists before subscribers subscribe. The stream emits items even if no subscribers observe the stream. If there are no subscribers, the items are just dropped. Subscribers only get items emitted after their subscription, meaning that any previous items would not be received. To create a hot stream, you can use io.smallrye.mutiny.operators.multi.processors.BroadcastProcessor that: drops items if no subscribers are present, forwards items to the set of observing subscribers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 BroadcastProcessor < String > processor = BroadcastProcessor . create (); Multi < String > multi = processor . onItem (). transform ( String :: toUpperCase ) . onFailure (). recoverWithItem ( \"d'oh\" ); new Thread (() -> { for ( int i = 0 ; i < 1000 ; i ++ ) { processor . onNext ( Integer . toString ( i )); } processor . onComplete (); }). start (); // Subscribers can subscribe at any time. // They will only receive items emitted after their subscription. // If the source is already terminated (by a completion or a failure signal) // the subscriber receives this signal. Note that the BroadcastProcessor subscribes to the hot source aggressively and without back-pressure. However, the BroadcastProcessor enforces the back-pressure protocol per subscriber. If a subscriber is not ready to handle an item emitted by the hot source, an io.smallrye.mutiny.subscription.BackPressureFailure is forwarded to this subscriber.","title":"Hot streams"},{"location":"guides/imperative-to-reactive/","tags":["guide","advanced"],"text":"From imperative to reactive # If you use Mutiny, there is a good chance you may want to avoid blocking the caller thread. In a pure reactive application, the application logic is executed on one of the few I/O threads, and blocking one of these would have dramatic consequences. So, here is the big question: how do you deal with blocking code? Let\u2019s imagine you have blocking code (e.g., connecting to a database using JDBC, reading a file from the file system\u2026), and you want to integrate that into your reactive pipelines while avoiding blocking. You would need to isolate such blocking parts of your code and run these parts on worker threads. Mutiny provides two operators to customize the threads used to handle events: runSubscriptionOn - to configure the thread used to execute the code happening at subscription-time emitOn - to configure the thread used to dispatch events downstream Running blocking code on subscription # It is very usual to deal with the blocking call during the subscription. In this case, the runSubscription operator is what you need: 1 2 3 Uni < String > uni = Uni . createFrom () . item ( this :: invokeRemoteServiceUsingBlockingIO ) . runSubscriptionOn ( Infrastructure . getDefaultWorkerPool ()); The code above creates a Uni that will supply the item using a blocking call, here the invokeRemoteServiceUsingBlockingIO method. To avoid blocking the subscriber thread, it uses runSubscriptionOn which switches the thread and call invokeRemoteServiceUsingBlockingIO on another thread. Here we pass the default worker thread pool, but you can use your own executor. Tip What\u2019s that default worker pool? In the previous snippet, you may wonder about Infrastructure.getDefaultWorkerPool() . Mutiny allows the underlying platform to provide a default worker pool. Infrastructure.getDefaultWorkerPool() provides access to this pool. If the underlying platform does not provide a pool, a default one is used. Note that runSubscriptionOn does not subscribe to the Uni. It specifies the executor to use when a subscription happens. While the snippet above uses Uni , you can also use runSubscriptionOn on a Multi . Executing blocking calls on event # Using runSubscriptionOn works when the blocking operation happens at subscription time. But, when dealing with Multi and need to execute blocking operations for each item, you need to use emitOn . While runSubscriptionOn runs the subscription on the given executor, emitOn configures the executor used to propagate downstream the items, failure and completion events: 1 2 3 Multi < String > multi = Multi . createFrom (). items ( \"john\" , \"jack\" , \"sue\" ) . emitOn ( Infrastructure . getDefaultWorkerPool ()) . onItem (). transform ( this :: invokeRemoteServiceUsingBlockingIO ); emitOn is also available on Uni . Warning Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.","title":"From imperative to reactive"},{"location":"guides/imperative-to-reactive/#from-imperative-to-reactive","text":"If you use Mutiny, there is a good chance you may want to avoid blocking the caller thread. In a pure reactive application, the application logic is executed on one of the few I/O threads, and blocking one of these would have dramatic consequences. So, here is the big question: how do you deal with blocking code? Let\u2019s imagine you have blocking code (e.g., connecting to a database using JDBC, reading a file from the file system\u2026), and you want to integrate that into your reactive pipelines while avoiding blocking. You would need to isolate such blocking parts of your code and run these parts on worker threads. Mutiny provides two operators to customize the threads used to handle events: runSubscriptionOn - to configure the thread used to execute the code happening at subscription-time emitOn - to configure the thread used to dispatch events downstream","title":"From imperative to reactive"},{"location":"guides/imperative-to-reactive/#running-blocking-code-on-subscription","text":"It is very usual to deal with the blocking call during the subscription. In this case, the runSubscription operator is what you need: 1 2 3 Uni < String > uni = Uni . createFrom () . item ( this :: invokeRemoteServiceUsingBlockingIO ) . runSubscriptionOn ( Infrastructure . getDefaultWorkerPool ()); The code above creates a Uni that will supply the item using a blocking call, here the invokeRemoteServiceUsingBlockingIO method. To avoid blocking the subscriber thread, it uses runSubscriptionOn which switches the thread and call invokeRemoteServiceUsingBlockingIO on another thread. Here we pass the default worker thread pool, but you can use your own executor. Tip What\u2019s that default worker pool? In the previous snippet, you may wonder about Infrastructure.getDefaultWorkerPool() . Mutiny allows the underlying platform to provide a default worker pool. Infrastructure.getDefaultWorkerPool() provides access to this pool. If the underlying platform does not provide a pool, a default one is used. Note that runSubscriptionOn does not subscribe to the Uni. It specifies the executor to use when a subscription happens. While the snippet above uses Uni , you can also use runSubscriptionOn on a Multi .","title":"Running blocking code on subscription"},{"location":"guides/imperative-to-reactive/#executing-blocking-calls-on-event","text":"Using runSubscriptionOn works when the blocking operation happens at subscription time. But, when dealing with Multi and need to execute blocking operations for each item, you need to use emitOn . While runSubscriptionOn runs the subscription on the given executor, emitOn configures the executor used to propagate downstream the items, failure and completion events: 1 2 3 Multi < String > multi = Multi . createFrom (). items ( \"john\" , \"jack\" , \"sue\" ) . emitOn ( Infrastructure . getDefaultWorkerPool ()) . onItem (). transform ( this :: invokeRemoteServiceUsingBlockingIO ); emitOn is also available on Uni . Warning Be careful as this operator can lead to concurrency problems with non thread-safe objects such as CDI request-scoped beans. It might also break reactive-streams semantics with items being emitted concurrently.","title":"Executing blocking calls on event"},{"location":"guides/integrate-a-non-reactive-source/","tags":["guide","advanced"],"text":"How can I create a Multi from a non-reactive source? # The UnicastProcessor is an implementation of Multi that lets you enqueue items in a queue. The items are then dispatched to the subscriber using the request protocol. While this pattern is against the idea of back-pressure, it lets you connect sources of data that do not support back-pressure with your subscriber. In the following example, the UnicastProcessor is used by a thread emitting items. These items are enqueued in the processor and replayed when the subscriber is connected, following the request protocol. 1 2 3 4 5 6 7 8 9 10 11 12 UnicastProcessor < String > processor = UnicastProcessor . create (); Multi < String > multi = processor . onItem (). transform ( String :: toUpperCase ) . onFailure (). recoverWithItem ( \"d'oh\" ); // Create a source of items that does not follow the request protocol new Thread (() -> { for ( int i = 0 ; i < 1000 ; i ++ ) { processor . onNext ( Integer . toString ( i )); } processor . onComplete (); }). start (); By default, the UnicastProcessor uses an unbounded queue. You can also pass a fixed size queue that would reject the items once full.","title":"How can I create a Multi from a non-reactive source?"},{"location":"guides/integrate-a-non-reactive-source/#how-can-i-create-a-multi-from-a-non-reactive-source","text":"The UnicastProcessor is an implementation of Multi that lets you enqueue items in a queue. The items are then dispatched to the subscriber using the request protocol. While this pattern is against the idea of back-pressure, it lets you connect sources of data that do not support back-pressure with your subscriber. In the following example, the UnicastProcessor is used by a thread emitting items. These items are enqueued in the processor and replayed when the subscriber is connected, following the request protocol. 1 2 3 4 5 6 7 8 9 10 11 12 UnicastProcessor < String > processor = UnicastProcessor . create (); Multi < String > multi = processor . onItem (). transform ( String :: toUpperCase ) . onFailure (). recoverWithItem ( \"d'oh\" ); // Create a source of items that does not follow the request protocol new Thread (() -> { for ( int i = 0 ; i < 1000 ; i ++ ) { processor . onNext ( Integer . toString ( i )); } processor . onComplete (); }). start (); By default, the UnicastProcessor uses an unbounded queue. You can also pass a fixed size queue that would reject the items once full.","title":"How can I create a Multi from a non-reactive source?"},{"location":"guides/joining-unis/","tags":["guide","intermediate"],"text":"Joining several unis # A Uni represents an operation that either emits a value or a failure. Examples of operations that fit into a Uni include: HTTP client requests, database insert queries, sending messages to a broker, etc. It is common to trigger several concurrent operations, then join on the results. For instance you can make HTTP requests to 3 different HTTP APIs, then collect all HTTP responses. Or you can just take the response from the one who was the fastest. Uni offers the join group to assemble all results from a list of Uni , pick the first one that terminates, or pick the first one that terminates with a value. Joining multiple unis # Given multiple Uni , you can join them all and obtain a Uni that emits a list of values: 1 2 3 4 5 Uni < Integer > a = Uni . createFrom (). item ( 1 ); Uni < Integer > b = Uni . createFrom (). item ( 2 ); Uni < Integer > c = Uni . createFrom (). item ( 3 ); Uni < List < Integer >> res = Uni . join (). all ( a , b , c ). andCollectFailures (); The assembled values are in the same order as the list of unis. The last call to .andCollectFailures() specifies that if one or several Uni fail, then the failures are assembled in a CompositeException . Sometimes you just want to fail fast if any of the Uni fails, and not wait for all unis to terminate: 1 res = Uni . join (). all ( a , b , c ). andFailFast (); When any Uni fails, then the failure is directly forwarded as a failure of res . Joining on the first Uni # In some cases you do not want to have all the results but just that of the first Uni to respond. There are actually 2 different cases, depending on whether you want the result of the first Uni that emits a value, or just the result of the first Uni to terminate. If you want to get the first Uni that terminates: 1 Uni < Integer > res = Uni . join (). first ( a , b , c ). toTerminate (); If you want to have the first Uni that emits a value (and forget the first failures), then: 1 res = Uni . join (). first ( a , b , c ). withItem (); When all unis fail then res fails with a CompositeException that reports all failures. Using a builder object # There are situations where it can be more convenient to gather the unis to join in an iterative fashion. For this purpose you can use a builder object, as in: 1 2 3 4 5 6 7 8 9 10 UniJoin . Builder < Integer > builder = Uni . join (). builder (); while ( someCondition ) { Uni < Integer > uni = supplier . get (); builder . add ( uni ); } Uni < List < Integer >> all = builder . joinAll (). andFailFast (); Uni < Integer > first = builder . joinFirst (). withItem (); The builder offers joinAll() and joinFirst() methods.","title":"Joining several unis"},{"location":"guides/joining-unis/#joining-several-unis","text":"A Uni represents an operation that either emits a value or a failure. Examples of operations that fit into a Uni include: HTTP client requests, database insert queries, sending messages to a broker, etc. It is common to trigger several concurrent operations, then join on the results. For instance you can make HTTP requests to 3 different HTTP APIs, then collect all HTTP responses. Or you can just take the response from the one who was the fastest. Uni offers the join group to assemble all results from a list of Uni , pick the first one that terminates, or pick the first one that terminates with a value.","title":"Joining several unis"},{"location":"guides/joining-unis/#joining-multiple-unis","text":"Given multiple Uni , you can join them all and obtain a Uni that emits a list of values: 1 2 3 4 5 Uni < Integer > a = Uni . createFrom (). item ( 1 ); Uni < Integer > b = Uni . createFrom (). item ( 2 ); Uni < Integer > c = Uni . createFrom (). item ( 3 ); Uni < List < Integer >> res = Uni . join (). all ( a , b , c ). andCollectFailures (); The assembled values are in the same order as the list of unis. The last call to .andCollectFailures() specifies that if one or several Uni fail, then the failures are assembled in a CompositeException . Sometimes you just want to fail fast if any of the Uni fails, and not wait for all unis to terminate: 1 res = Uni . join (). all ( a , b , c ). andFailFast (); When any Uni fails, then the failure is directly forwarded as a failure of res .","title":"Joining multiple unis"},{"location":"guides/joining-unis/#joining-on-the-first-uni","text":"In some cases you do not want to have all the results but just that of the first Uni to respond. There are actually 2 different cases, depending on whether you want the result of the first Uni that emits a value, or just the result of the first Uni to terminate. If you want to get the first Uni that terminates: 1 Uni < Integer > res = Uni . join (). first ( a , b , c ). toTerminate (); If you want to have the first Uni that emits a value (and forget the first failures), then: 1 res = Uni . join (). first ( a , b , c ). withItem (); When all unis fail then res fails with a CompositeException that reports all failures.","title":"Joining on the first Uni"},{"location":"guides/joining-unis/#using-a-builder-object","text":"There are situations where it can be more convenient to gather the unis to join in an iterative fashion. For this purpose you can use a builder object, as in: 1 2 3 4 5 6 7 8 9 10 UniJoin . Builder < Integer > builder = Uni . join (). builder (); while ( someCondition ) { Uni < Integer > uni = supplier . get (); builder . add ( uni ); } Uni < List < Integer >> all = builder . joinAll (). andFailFast (); Uni < Integer > first = builder . joinFirst (). withItem (); The builder offers joinAll() and joinFirst() methods.","title":"Using a builder object"},{"location":"guides/kotlin/","tags":["guide","intermediate"],"text":"Kotlin integration # The module mutiny-kotlin provides an integration with Kotlin for use with coroutines and convenient language features. There are extension methods available for converting between Mutiny and Kotlin (coroutine) types. For implementation details please have also a look to these methods\u2019 documentation. Dependency coordinates # The coroutine extension functions are shipped in the package io.smallrye.mutiny.coroutines . 1 2 3 4 import io.smallrye.mutiny.coroutines.asFlow import io.smallrye.mutiny.coroutines.asMulti import io.smallrye.mutiny.coroutines.asUni import io.smallrye.mutiny.coroutines.awaitSuspending You need to add the following dependency to your project: Maven Gradle (Kotlin) Gradle (Groovy) <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-kotlin </artifactId> <version> 2.1.0 </version> </dependency> implementation ( \"io.smallrye.reactive:mutiny-kotlin:2.1.0\" ) implementation \"io.smallrye.reactive:mutiny-kotlin:2.1.0\" Awaiting a Uni in coroutines # Within a coroutine or suspend function you can easily await Uni events in a suspended way: 1 2 3 4 5 6 7 val uni : Uni < String > = Uni . createFrom (). item ( \"Mutiny \u2764 Kotlin\" ) try { // Available within suspend function and CoroutineScope val item : String = uni . awaitSuspending () } catch ( failure : Throwable ) { // onFailure event happened } Processing a Multi as Flow # The coroutine Flow type matches Multi semantically, even though it isn\u2019t a feature complete reactive streams implementation. You can process a Multi as Flow as follows: 1 2 val multi : Multi < String > = Multi . createFrom (). items ( \"Mutiny\" , \"\u2764\" , \"Kotlin\" ) val flow : Flow < String > = multi . asFlow () Note There\u2019s no flow control availabe for Kotlin\u2019s Flow . Published items are buffered for consumption using a coroutine Channel . The buffer size and overflow strategy of that Channel can be configured using optional arguments: Multi.asFlow(bufferCapacity = Channel.UNLIMITED, bufferOverflowStrategy = BufferOverflow.SUSPEND) , for more details please consult the method documentation. Providing a Deferred value as Uni # The other way around is also possible, let a Deferred become a Uni: 1 2 val deferred : Deferred < String > = GlobalScope . async { \"Kotlin \u2764 Mutiny\" } val uni : Uni < String > = deferred . asUni () Creating a Multi from a Flow # Finally, creating a Multi from a Flow is also possible: 1 2 val flow : Flow < String > = flowOf ( \"Kotlin\" , \"\u2764\" , \"Mutiny\" ) val multi : Multi < String > = flow . asMulti () Language convenience # Unit instead of Void (null) value # Kotlin has a special value type Unit similar to Java\u2019s Void . While regular Uni<Void> holds a null item, you can get a Unit by using the extension function replaceWithUnit() : 1 2 3 // import io.smallrye.mutiny.replaceWithUnit val unitUni : Uni < Unit > = uni . replaceWithUnit () assert ( unitUni . await (). indefinitely () === Unit ) Uni builder # Building a Uni from Kotlin code can easily be achieved using the following builders available as regular or coroutine variant: 1 2 // import io.smallrye.mutiny.uni val uni : Uni < String > = uni { \"\u03bb \ud83d\udea7\" } 1 2 3 4 // import io.smallrye.mutiny.coroutines.uni coroutineScope { val uni : Uni < String > = uni { \"\u03bb \ud83d\udea7\" } }","title":"Kotlin integration"},{"location":"guides/kotlin/#kotlin-integration","text":"The module mutiny-kotlin provides an integration with Kotlin for use with coroutines and convenient language features. There are extension methods available for converting between Mutiny and Kotlin (coroutine) types. For implementation details please have also a look to these methods\u2019 documentation.","title":"Kotlin integration"},{"location":"guides/kotlin/#dependency-coordinates","text":"The coroutine extension functions are shipped in the package io.smallrye.mutiny.coroutines . 1 2 3 4 import io.smallrye.mutiny.coroutines.asFlow import io.smallrye.mutiny.coroutines.asMulti import io.smallrye.mutiny.coroutines.asUni import io.smallrye.mutiny.coroutines.awaitSuspending You need to add the following dependency to your project: Maven Gradle (Kotlin) Gradle (Groovy) <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny-kotlin </artifactId> <version> 2.1.0 </version> </dependency> implementation ( \"io.smallrye.reactive:mutiny-kotlin:2.1.0\" ) implementation \"io.smallrye.reactive:mutiny-kotlin:2.1.0\"","title":"Dependency coordinates"},{"location":"guides/kotlin/#awaiting-a-uni-in-coroutines","text":"Within a coroutine or suspend function you can easily await Uni events in a suspended way: 1 2 3 4 5 6 7 val uni : Uni < String > = Uni . createFrom (). item ( \"Mutiny \u2764 Kotlin\" ) try { // Available within suspend function and CoroutineScope val item : String = uni . awaitSuspending () } catch ( failure : Throwable ) { // onFailure event happened }","title":"Awaiting a Uni in coroutines"},{"location":"guides/kotlin/#processing-a-multi-as-flow","text":"The coroutine Flow type matches Multi semantically, even though it isn\u2019t a feature complete reactive streams implementation. You can process a Multi as Flow as follows: 1 2 val multi : Multi < String > = Multi . createFrom (). items ( \"Mutiny\" , \"\u2764\" , \"Kotlin\" ) val flow : Flow < String > = multi . asFlow () Note There\u2019s no flow control availabe for Kotlin\u2019s Flow . Published items are buffered for consumption using a coroutine Channel . The buffer size and overflow strategy of that Channel can be configured using optional arguments: Multi.asFlow(bufferCapacity = Channel.UNLIMITED, bufferOverflowStrategy = BufferOverflow.SUSPEND) , for more details please consult the method documentation.","title":"Processing a Multi as Flow"},{"location":"guides/kotlin/#providing-a-deferred-value-as-uni","text":"The other way around is also possible, let a Deferred become a Uni: 1 2 val deferred : Deferred < String > = GlobalScope . async { \"Kotlin \u2764 Mutiny\" } val uni : Uni < String > = deferred . asUni ()","title":"Providing a Deferred value as Uni"},{"location":"guides/kotlin/#creating-a-multi-from-a-flow","text":"Finally, creating a Multi from a Flow is also possible: 1 2 val flow : Flow < String > = flowOf ( \"Kotlin\" , \"\u2764\" , \"Mutiny\" ) val multi : Multi < String > = flow . asMulti ()","title":"Creating a Multi from a Flow"},{"location":"guides/kotlin/#language-convenience","text":"","title":"Language convenience"},{"location":"guides/kotlin/#unit-instead-of-void-null-value","text":"Kotlin has a special value type Unit similar to Java\u2019s Void . While regular Uni<Void> holds a null item, you can get a Unit by using the extension function replaceWithUnit() : 1 2 3 // import io.smallrye.mutiny.replaceWithUnit val unitUni : Uni < Unit > = uni . replaceWithUnit () assert ( unitUni . await (). indefinitely () === Unit )","title":"Unit instead of Void (null) value"},{"location":"guides/kotlin/#uni-builder","text":"Building a Uni from Kotlin code can easily be achieved using the following builders available as regular or coroutine variant: 1 2 // import io.smallrye.mutiny.uni val uni : Uni < String > = uni { \"\u03bb \ud83d\udea7\" } 1 2 3 4 // import io.smallrye.mutiny.coroutines.uni coroutineScope { val uni : Uni < String > = uni { \"\u03bb \ud83d\udea7\" } }","title":"Uni builder"},{"location":"guides/logging/","tags":["guide","beginner"],"text":"Logging events # Both Uni and Multi offer a log operator that can be used to trace events as they flow through operators. Mutiny does not make any assumption on how logging is defined, and does not rely on any specific logging API. Using a logging operator # The log method comes in 2 forms: one that takes an identifier and one that derives the identifier from the upstream class: 1 2 3 4 Multi . createFrom (). items ( 1 , 2 , 3 ) . onItem (). transform ( n -> n * 10 ) . log () . subscribe (). with ( item -> System . out . println ( \">>> \" + item )); Here the log operator traces all events between the onItem().transform(...) operator and the subscriber, as in the following output: 11:01:48.709 [main] INFO Multi.MultiMapOp.0 - onSubscription() 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - request(9223372036854775807) 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(10) >>> 10 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(20) >>> 20 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(30) >>> 30 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onCompletion() There are a few things to note here: we are logging on a Multi , so the logging event is prefixed with Multi (and Uni in the case of a\u2026 Uni ), and since we did not specify any identifier in the log method call, MultiMapOp has been derived from the preceding operator (non-qualified) class name, and since there can be multiple subscriptions an integer is appended to the identifier ( 0 , 1 , 2 , \u2026). Defining logging # What happens when events are being logged is defined with the Infrastructure class. Events are written by default to the standard console output in a format similar to: [--> Multi.MultiMapOp.0 | onSubscription() [--> Multi.MultiMapOp.0 | request(9223372036854775807) [--> Multi.MultiMapOp.0 | onItem(10) [--> Multi.MultiMapOp.0 | onItem(20) [--> Multi.MultiMapOp.0 | onItem(30) [--> Multi.MultiMapOp.0 | onCompletion() The following is an example of configuring logging with http://www.slf4j.org[SLF4J]: 1 2 3 4 5 6 7 8 9 10 11 12 Infrastructure . setOperatorLogger (( id , event , value , err ) -> { Logger logger = LoggerFactory . getLogger ( id ); if ( err != null ) { logger . info ( event + \"(\" + err . getClass () + \"(\" + err . getMessage () + \"))\" ); } else { if ( value != null ) { logger . info ( event + \"(\" + value + \")\" ); } else { logger . info ( event + \"()\" ); } } }); Tip Note that this is only useful to do when embedding Mutiny in your own stack, some frameworks like Quarkus will already have defined the correct logging strategy.","title":"Logging events"},{"location":"guides/logging/#logging-events","text":"Both Uni and Multi offer a log operator that can be used to trace events as they flow through operators. Mutiny does not make any assumption on how logging is defined, and does not rely on any specific logging API.","title":"Logging events"},{"location":"guides/logging/#using-a-logging-operator","text":"The log method comes in 2 forms: one that takes an identifier and one that derives the identifier from the upstream class: 1 2 3 4 Multi . createFrom (). items ( 1 , 2 , 3 ) . onItem (). transform ( n -> n * 10 ) . log () . subscribe (). with ( item -> System . out . println ( \">>> \" + item )); Here the log operator traces all events between the onItem().transform(...) operator and the subscriber, as in the following output: 11:01:48.709 [main] INFO Multi.MultiMapOp.0 - onSubscription() 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - request(9223372036854775807) 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(10) >>> 10 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(20) >>> 20 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onItem(30) >>> 30 11:01:48.711 [main] INFO Multi.MultiMapOp.0 - onCompletion() There are a few things to note here: we are logging on a Multi , so the logging event is prefixed with Multi (and Uni in the case of a\u2026 Uni ), and since we did not specify any identifier in the log method call, MultiMapOp has been derived from the preceding operator (non-qualified) class name, and since there can be multiple subscriptions an integer is appended to the identifier ( 0 , 1 , 2 , \u2026).","title":"Using a logging operator"},{"location":"guides/logging/#defining-logging","text":"What happens when events are being logged is defined with the Infrastructure class. Events are written by default to the standard console output in a format similar to: [--> Multi.MultiMapOp.0 | onSubscription() [--> Multi.MultiMapOp.0 | request(9223372036854775807) [--> Multi.MultiMapOp.0 | onItem(10) [--> Multi.MultiMapOp.0 | onItem(20) [--> Multi.MultiMapOp.0 | onItem(30) [--> Multi.MultiMapOp.0 | onCompletion() The following is an example of configuring logging with http://www.slf4j.org[SLF4J]: 1 2 3 4 5 6 7 8 9 10 11 12 Infrastructure . setOperatorLogger (( id , event , value , err ) -> { Logger logger = LoggerFactory . getLogger ( id ); if ( err != null ) { logger . info ( event + \"(\" + err . getClass () + \"(\" + err . getMessage () + \"))\" ); } else { if ( value != null ) { logger . info ( event + \"(\" + value + \")\" ); } else { logger . info ( event + \"()\" ); } } }); Tip Note that this is only useful to do when embedding Mutiny in your own stack, some frameworks like Quarkus will already have defined the correct logging strategy.","title":"Defining logging"},{"location":"guides/merging-and-concatenating-streams/","tags":["guide","intermediate"],"text":"Merging and Concatenating Streams # Merging or concatenating streams is a frequent operation which consists in taking multiple streams and creating a new Multi out of them. Such an operation observes the items emitted by the different streams and produces a new Multi emitting the events. All the streams merged or concatenated this way should emit the same type of items. The difference between merge and concatenate # Understanding the difference between merge and concatenate is essential. When merging streams, it observes the different upstreams and emits the items as they come. If the streams emit their items concurrently, the items from the different streams are interleaved. sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Merged stream M-->>A: subscribe M-->>B: subscribe A-->>M: onSubscribe(s) A->>M: onItem(1) B-->>M: onSubscribe(s) A->>M: onItem(2) B->>M: onItem(a) A->>M: onItem(3) B->>M: onItem(b) B->>M: onItem(c) When using merge , failures are also propagated to the merged stream, and no more items are emitted after that failure. The completion event is only emitted by the merged stream when all the observed streams are completed. But if we want to keep the order of the observed stream, we need to concatenate . When concatenating , it waits for the first stream to complete before subscribing to the second one. Thus, it ensures that all the items from the first stream have been emitted before emitting the second stream items. It preserves an order corresponding to the source: sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant C as Concatenated stream C-->>A: subscribe A-->>C: onSubscribe(s) A->>C: onItem(1) A->>C: onItem(2) A->>C: onItem(3) A-->>C: onCompletion() C-->>B: subscribe B-->>C: onSubscribe(s) B->>C: onItem(a) B->>C: onItem(b) B->>C: onItem(c) When the first stream emits the completion event, it switches to the second stream, and so on. When the last stream completes, the concatenated stream sends the completion event. As for merge , if a stream fails then there won\u2019t be further events. Merging Multis # To create a new Multi from the merge of multiple Multi streams use: 1 2 3 4 Multi < T > multi1 = getFirstMulti (); Multi < T > multi2 = getSecondMulti (); Multi < T > merged = Multi . createBy (). merging (). streams ( multi1 , multi2 ); For example, we can merge multiple streams emitting periodical events: 1 2 3 4 5 6 7 8 9 10 11 Multi < String > first = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 10 )) . onItem (). transform ( l -> \"Stream 1 - \" + l ); Multi < String > second = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 15 )) . onItem (). transform ( l -> \"Stream 2 - \" + l ); Multi < String > third = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 5 )) . onItem (). transform ( l -> \"Stream 3 - \" + l ); Cancellable cancellable = Multi . createBy (). merging (). streams ( first , second , third ) . subscribe (). with ( s -> System . out . println ( \"Got item: \" + s )); and the output would be similar to: Got item: Stream 1 - 0 Got item: Stream 2 - 0 Got item: Stream 3 - 0 Got item: Stream 3 - 1 Got item: Stream 1 - 1 Got item: Stream 3 - 2 Got item: Stream 2 - 1 Got item: Stream 3 - 3 Got item: Stream 1 - 2 Got item: Stream 3 - 4 Got item: Stream 3 - 5 Concatenating Multis # To create a new Multi from the concatenation of multiple Multi streams use: 1 2 3 4 Multi < T > multi1 = getFirstMulti (); Multi < T > multi2 = getSecondMulti (); Multi < T > concatenated = Multi . createBy (). concatenating (). streams ( multi1 , multi2 ); Don\u2019t forget that the streams order matters in this case, as (streamA, streamB) does not provide the same result as (streamB, streamA) : 1 2 3 4 5 6 7 8 Multi < String > first = Multi . createFrom (). items ( \"A1\" , \"A2\" , \"A3\" ); Multi < String > second = Multi . createFrom (). items ( \"B1\" , \"B2\" , \"B3\" ); Multi . createBy (). concatenating (). streams ( first , second ) . subscribe (). with ( item -> System . out . print ( item )); // \"A1A2A3B1B2B3\" Multi . createBy (). concatenating (). streams ( second , first ) . subscribe (). with ( item -> System . out . print ( item )); // \"B1B2B3A1A2A3\" Important If one of the concatenated streams is unbounded (infinite), the next streams in the list won\u2019t be consumed!","title":"Merging and Concatenating Streams"},{"location":"guides/merging-and-concatenating-streams/#merging-and-concatenating-streams","text":"Merging or concatenating streams is a frequent operation which consists in taking multiple streams and creating a new Multi out of them. Such an operation observes the items emitted by the different streams and produces a new Multi emitting the events. All the streams merged or concatenated this way should emit the same type of items.","title":"Merging and Concatenating Streams"},{"location":"guides/merging-and-concatenating-streams/#the-difference-between-merge-and-concatenate","text":"Understanding the difference between merge and concatenate is essential. When merging streams, it observes the different upstreams and emits the items as they come. If the streams emit their items concurrently, the items from the different streams are interleaved. sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant M as Merged stream M-->>A: subscribe M-->>B: subscribe A-->>M: onSubscribe(s) A->>M: onItem(1) B-->>M: onSubscribe(s) A->>M: onItem(2) B->>M: onItem(a) A->>M: onItem(3) B->>M: onItem(b) B->>M: onItem(c) When using merge , failures are also propagated to the merged stream, and no more items are emitted after that failure. The completion event is only emitted by the merged stream when all the observed streams are completed. But if we want to keep the order of the observed stream, we need to concatenate . When concatenating , it waits for the first stream to complete before subscribing to the second one. Thus, it ensures that all the items from the first stream have been emitted before emitting the second stream items. It preserves an order corresponding to the source: sequenceDiagram autonumber participant A as Stream A participant B as Stream B participant C as Concatenated stream C-->>A: subscribe A-->>C: onSubscribe(s) A->>C: onItem(1) A->>C: onItem(2) A->>C: onItem(3) A-->>C: onCompletion() C-->>B: subscribe B-->>C: onSubscribe(s) B->>C: onItem(a) B->>C: onItem(b) B->>C: onItem(c) When the first stream emits the completion event, it switches to the second stream, and so on. When the last stream completes, the concatenated stream sends the completion event. As for merge , if a stream fails then there won\u2019t be further events.","title":"The difference between merge and concatenate"},{"location":"guides/merging-and-concatenating-streams/#merging-multis","text":"To create a new Multi from the merge of multiple Multi streams use: 1 2 3 4 Multi < T > multi1 = getFirstMulti (); Multi < T > multi2 = getSecondMulti (); Multi < T > merged = Multi . createBy (). merging (). streams ( multi1 , multi2 ); For example, we can merge multiple streams emitting periodical events: 1 2 3 4 5 6 7 8 9 10 11 Multi < String > first = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 10 )) . onItem (). transform ( l -> \"Stream 1 - \" + l ); Multi < String > second = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 15 )) . onItem (). transform ( l -> \"Stream 2 - \" + l ); Multi < String > third = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 5 )) . onItem (). transform ( l -> \"Stream 3 - \" + l ); Cancellable cancellable = Multi . createBy (). merging (). streams ( first , second , third ) . subscribe (). with ( s -> System . out . println ( \"Got item: \" + s )); and the output would be similar to: Got item: Stream 1 - 0 Got item: Stream 2 - 0 Got item: Stream 3 - 0 Got item: Stream 3 - 1 Got item: Stream 1 - 1 Got item: Stream 3 - 2 Got item: Stream 2 - 1 Got item: Stream 3 - 3 Got item: Stream 1 - 2 Got item: Stream 3 - 4 Got item: Stream 3 - 5","title":"Merging Multis"},{"location":"guides/merging-and-concatenating-streams/#concatenating-multis","text":"To create a new Multi from the concatenation of multiple Multi streams use: 1 2 3 4 Multi < T > multi1 = getFirstMulti (); Multi < T > multi2 = getSecondMulti (); Multi < T > concatenated = Multi . createBy (). concatenating (). streams ( multi1 , multi2 ); Don\u2019t forget that the streams order matters in this case, as (streamA, streamB) does not provide the same result as (streamB, streamA) : 1 2 3 4 5 6 7 8 Multi < String > first = Multi . createFrom (). items ( \"A1\" , \"A2\" , \"A3\" ); Multi < String > second = Multi . createFrom (). items ( \"B1\" , \"B2\" , \"B3\" ); Multi . createBy (). concatenating (). streams ( first , second ) . subscribe (). with ( item -> System . out . print ( item )); // \"A1A2A3B1B2B3\" Multi . createBy (). concatenating (). streams ( second , first ) . subscribe (). with ( item -> System . out . print ( item )); // \"B1B2B3A1A2A3\" Important If one of the concatenated streams is unbounded (infinite), the next streams in the list won\u2019t be consumed!","title":"Concatenating Multis"},{"location":"guides/pagination/","tags":["guide","intermediate"],"text":"How to use paginated APIs? # There are many REST / HTTP APIs using pagination, i.e. return only a subset of the results and you need to request the next page to get the next batch. Each batch contains a list of item(s). To use this kind of API and generate a continuous stream of items, you need to use the Multi.createBy().repeating() function. However, we need to pass a cursor / state to advance and avoid requesting again and again the same page. Fortunately, repeating provides methods to pass a shared state. So by combining these methods and disjoint you can generate streams from these pages: 1 2 3 4 5 6 7 8 PaginatedApi api = new PaginatedApi (); Multi < String > stream = Multi . createBy (). repeating () . completionStage ( () -> new AtomicInteger (), state -> api . getPage ( state . getAndIncrement ())) . until ( list -> list . isEmpty ()) . onItem (). disjoint (); First, you create a Multi containing the items emitted by the CompletionStage supplier and pass a state supplier to progress among the pages. Then, use until to call the paginated API until we have all the items. At the point we have a stream of list of item such as [\"a\", \"b\", \"c\"], [\"d\", \"e\"], [] . However, we want the following stream: \"a\", \"b\", \"c\", \"d\", \"e\" . The disjoint method does exactly this. It gets the items from the lists and passes them downstream: sequenceDiagram autonumber participant M as Multi participant O as Disjoint operator participant D as Subscriber M->>O: onItem([a,b,c]) O->>D: onItem(a) O->>D: onItem(b) O->>D: onItem(c) M->>O: onItem([d,e]) O->>D: onItem(d) O->>D: onItem(e) Multi.createBy().repeating() lets you choose the number of iterations using: atMost - exact number of repetitions (or failure happens before reaching that number) until - the repetition is stopped if the item emitted by the Uni passes a test (predicate). It does not propagate the item that did pass the check, and it stops the repetition. The check verifies if the current item does not contain valid data. whilst - the repetition is stopped if the item emitted by the Uni does not pass a test (predicate). It does propagate the item downstream even if the check does not pass. However, it stops the repetition. The test verifies if there is a next batch to be retrieved. The following code illustrates the usage of whilst : 1 2 3 4 5 6 7 PaginatedApi api = new PaginatedApi (); Multi < Page > stream = Multi . createBy (). repeating () . uni ( () -> new AtomicInteger (), state -> api . retrieve ( state . getAndIncrement ())) . whilst ( page -> page . hasNext ());","title":"How to use paginated APIs?"},{"location":"guides/pagination/#how-to-use-paginated-apis","text":"There are many REST / HTTP APIs using pagination, i.e. return only a subset of the results and you need to request the next page to get the next batch. Each batch contains a list of item(s). To use this kind of API and generate a continuous stream of items, you need to use the Multi.createBy().repeating() function. However, we need to pass a cursor / state to advance and avoid requesting again and again the same page. Fortunately, repeating provides methods to pass a shared state. So by combining these methods and disjoint you can generate streams from these pages: 1 2 3 4 5 6 7 8 PaginatedApi api = new PaginatedApi (); Multi < String > stream = Multi . createBy (). repeating () . completionStage ( () -> new AtomicInteger (), state -> api . getPage ( state . getAndIncrement ())) . until ( list -> list . isEmpty ()) . onItem (). disjoint (); First, you create a Multi containing the items emitted by the CompletionStage supplier and pass a state supplier to progress among the pages. Then, use until to call the paginated API until we have all the items. At the point we have a stream of list of item such as [\"a\", \"b\", \"c\"], [\"d\", \"e\"], [] . However, we want the following stream: \"a\", \"b\", \"c\", \"d\", \"e\" . The disjoint method does exactly this. It gets the items from the lists and passes them downstream: sequenceDiagram autonumber participant M as Multi participant O as Disjoint operator participant D as Subscriber M->>O: onItem([a,b,c]) O->>D: onItem(a) O->>D: onItem(b) O->>D: onItem(c) M->>O: onItem([d,e]) O->>D: onItem(d) O->>D: onItem(e) Multi.createBy().repeating() lets you choose the number of iterations using: atMost - exact number of repetitions (or failure happens before reaching that number) until - the repetition is stopped if the item emitted by the Uni passes a test (predicate). It does not propagate the item that did pass the check, and it stops the repetition. The check verifies if the current item does not contain valid data. whilst - the repetition is stopped if the item emitted by the Uni does not pass a test (predicate). It does propagate the item downstream even if the check does not pass. However, it stops the repetition. The test verifies if there is a next batch to be retrieved. The following code illustrates the usage of whilst : 1 2 3 4 5 6 7 PaginatedApi api = new PaginatedApi (); Multi < Page > stream = Multi . createBy (). repeating () . uni ( () -> new AtomicInteger (), state -> api . retrieve ( state . getAndIncrement ())) . whilst ( page -> page . hasNext ());","title":"How to use paginated APIs?"},{"location":"guides/polling/","tags":["guide","advanced"],"text":"How to use polling? # There are many poll-based API around us. Sometimes you need to use these APIs to generate a stream from the polled values. To do this, use the repeat() feature: 1 2 3 4 5 6 7 8 9 10 11 12 13 PollableDataSource source = new PollableDataSource (); // First creates a uni that emit the polled item. // Because `poll` blocks, let's use a specific executor Uni < String > pollItemFromSource = Uni . createFrom (). item ( source :: poll ) . runSubscriptionOn ( executor ); // To get the stream of items, just repeat the uni indefinitely Multi < String > stream = pollItemFromSource . repeat (). indefinitely (); Cancellable cancellable = stream . subscribe (). with ( item -> System . out . println ( \"Polled item: \" + item )); // ... later .. // when you don't want the items anymore, cancel the subscription and close the source if needed. cancellable . cancel (); source . close (); You can also stop the repetition using the repeat().until() method which will continue the repetition until the given predicate returns true , and/or directly create a Multi using Multi.createBy().repeating() : 1 2 3 4 5 6 7 PollableDataSource source = new PollableDataSource (); Multi < String > stream = Multi . createBy (). repeating () . supplier ( source :: poll ) . until ( s -> s == null ) . runSubscriptionOn ( executor ); stream . subscribe (). with ( item -> System . out . println ( \"Polled item: \" + item ));","title":"How to use polling?"},{"location":"guides/polling/#how-to-use-polling","text":"There are many poll-based API around us. Sometimes you need to use these APIs to generate a stream from the polled values. To do this, use the repeat() feature: 1 2 3 4 5 6 7 8 9 10 11 12 13 PollableDataSource source = new PollableDataSource (); // First creates a uni that emit the polled item. // Because `poll` blocks, let's use a specific executor Uni < String > pollItemFromSource = Uni . createFrom (). item ( source :: poll ) . runSubscriptionOn ( executor ); // To get the stream of items, just repeat the uni indefinitely Multi < String > stream = pollItemFromSource . repeat (). indefinitely (); Cancellable cancellable = stream . subscribe (). with ( item -> System . out . println ( \"Polled item: \" + item )); // ... later .. // when you don't want the items anymore, cancel the subscription and close the source if needed. cancellable . cancel (); source . close (); You can also stop the repetition using the repeat().until() method which will continue the repetition until the given predicate returns true , and/or directly create a Multi using Multi.createBy().repeating() : 1 2 3 4 5 6 7 PollableDataSource source = new PollableDataSource (); Multi < String > stream = Multi . createBy (). repeating () . supplier ( source :: poll ) . until ( s -> s == null ) . runSubscriptionOn ( executor ); stream . subscribe (). with ( item -> System . out . println ( \"Polled item: \" + item ));","title":"How to use polling?"},{"location":"guides/reactive-to-imperative/","tags":["guide","advanced"],"text":"From reactive to imperative # There are use cases where you need the items in an imperative manner instead of asynchronous. Typically, when you serve an HTTP request from a worker thread, you can block. Mutiny provides the ability to block until you get the items. Awaiting on Uni\u2019s item # When dealing with a Uni, you can block and await the item using: 1 T t = uni . await (). indefinitely (); This method blocks the caller thread until the observed uni emits the item. Note that the returned item can be null if the uni emits null. If the uni fails, it throws the exception, wrapped in the CompletionException for checked exception. Blocking forever may not be a great idea. You can use uni.await().atMost(Duration) to pass a deadline. When the deadline is reached, a TimeoutException is thrown: 1 T t = uni . await (). atMost ( Duration . ofSeconds ( 1 )); Iterating over Multi\u2019s items # When dealing with a Multi, you may want to iterate over the items using a simple \u201cforeach.\u201d You can achieve this using multi.subscribe().asIterable() : 1 2 3 4 Iterable < T > iterable = multi . subscribe (). asIterable (); for ( T item : iterable ) { doSomethingWithItem ( item ); } The returned iterable is blocking. It waits for the next items, and during that time, blocks the caller thread. The iteration ends once the last item is consumed. If the multi emits a failure, an exception is thrown. Similar to asIterable() , the asStream method lets you retrieve a java.util.stream.Stream : 1 2 Stream < T > stream = multi . subscribe (). asStream (); stream . forEach ( this :: doSomethingWithItem );","title":"From reactive to imperative"},{"location":"guides/reactive-to-imperative/#from-reactive-to-imperative","text":"There are use cases where you need the items in an imperative manner instead of asynchronous. Typically, when you serve an HTTP request from a worker thread, you can block. Mutiny provides the ability to block until you get the items.","title":"From reactive to imperative"},{"location":"guides/reactive-to-imperative/#awaiting-on-unis-item","text":"When dealing with a Uni, you can block and await the item using: 1 T t = uni . await (). indefinitely (); This method blocks the caller thread until the observed uni emits the item. Note that the returned item can be null if the uni emits null. If the uni fails, it throws the exception, wrapped in the CompletionException for checked exception. Blocking forever may not be a great idea. You can use uni.await().atMost(Duration) to pass a deadline. When the deadline is reached, a TimeoutException is thrown: 1 T t = uni . await (). atMost ( Duration . ofSeconds ( 1 ));","title":"Awaiting on Uni's item"},{"location":"guides/reactive-to-imperative/#iterating-over-multis-items","text":"When dealing with a Multi, you may want to iterate over the items using a simple \u201cforeach.\u201d You can achieve this using multi.subscribe().asIterable() : 1 2 3 4 Iterable < T > iterable = multi . subscribe (). asIterable (); for ( T item : iterable ) { doSomethingWithItem ( item ); } The returned iterable is blocking. It waits for the next items, and during that time, blocks the caller thread. The iteration ends once the last item is consumed. If the multi emits a failure, an exception is thrown. Similar to asIterable() , the asStream method lets you retrieve a java.util.stream.Stream : 1 2 Stream < T > stream = multi . subscribe (). asStream (); stream . forEach ( this :: doSomethingWithItem );","title":"Iterating over Multi's items"},{"location":"guides/replaying-multis/","tags":["guide","advanced"],"text":"Replaying Multis # A Multi is a cold-source : no processing happens until you subscribe. While the broadcast operator can be used so that multiple subscribers consume a Multi events at the same time , it does not support replaying items for late subscribers : when a subscriber joins after the Multi has completed (or failed), then it won\u2019t receive any item. This is where replaying can be useful. Replaying all events # Replaying all events from an upstream Multi works as follows: 1 2 3 4 5 6 Multi < Integer > upstream = Multi . createFrom (). range ( 0 , 10 ); Multi < Integer > replay = Multi . createBy (). replaying (). ofMulti ( upstream ); List < Integer > items_1 = replay . collect (). asList (). await (). indefinitely (); List < Integer > items_2 = replay . collect (). asList (). await (). indefinitely (); Both item_1 and item_2 trigger new subscriptions, and both lists contain the following elements: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Replaying works by turning upstream into a hot-stream , meaning that it gets requested Long.MAX_VALUE elements. This is done when the first subscription happens. The replay operator stores the items in an internal replay log , and then each subscriber gets to replay them. Important Subscribers demand and cancellation requests are honored while replaying, but upstream cannot be cancelled. Be careful with unbounded streams as you can exhaust memory! In such cases or when you need to replay large amounts of data, you might opt to use some eventing middleware rather than Mutiny replays. Replaying the last \u2018n\u2019 events # You can limit the number of elements to replay by using the upTo method: 1 2 3 4 5 6 Multi < Integer > upstream = Multi . createFrom (). range ( 0 , 10 ); Multi < Integer > replay = Multi . createBy (). replaying (). upTo ( 3 ). ofMulti ( upstream ); List < Integer > items_1 = replay . collect (). asList (). await (). indefinitely (); List < Integer > items_2 = replay . collect (). asList (). await (). indefinitely (); Each new subscriber gets to replay the last n elements from where the replay log is at subscription time. For instance the first subscriber can observe all events, while a subscriber that joins 2 seconds later might not observe the earlier events. Since Multi.createFrom().range(0, 10) is an immediate stream, both item_1 and item_2 lists contain the last items: [7, 8, 9] Prepending with seed data # In some cases you might want to prepend some seed data that will be available for replay before the upstream starts emitting. You can do so using an Iterable to provide such seed data: 1 2 3 4 5 6 7 Multi < Integer > upstream = Multi . createFrom (). range ( 0 , 10 ); Iterable < Integer > seed = Arrays . asList ( - 10 , - 5 , - 1 ); Multi < Integer > replay = Multi . createBy (). replaying (). ofSeedAndMulti ( seed , upstream ); List < Integer > items_1 = replay . collect (). asList (). await (). indefinitely (); List < Integer > items_2 = replay . collect (). asList (). await (). indefinitely (); In which case subscribers can observe the following events: [-10, -5, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Replay of failures and completions # Subscribers get to observe not just items but also the failure and completion events: 1 2 3 4 5 6 7 8 9 10 11 Multi < Integer > upstream = Multi . createBy (). concatenating (). streams ( Multi . createFrom (). range ( 0 , 10 ), Multi . createFrom (). failure (() -> new IOException ( \"boom\" )) ); Multi < Integer > replay = Multi . createBy (). replaying (). upTo ( 3 ). ofMulti ( upstream ); replay . subscribe (). with ( n -> System . out . println ( \" -> \" + n ), failure -> System . out . println ( \"Failed: \" + failure . getMessage ()), () -> System . out . println ( \"Completed\" )); Running this code yields the following output for any subscriber: -> 7 -> 8 -> 9 Failed: boom","title":"Replaying Multis"},{"location":"guides/replaying-multis/#replaying-multis","text":"A Multi is a cold-source : no processing happens until you subscribe. While the broadcast operator can be used so that multiple subscribers consume a Multi events at the same time , it does not support replaying items for late subscribers : when a subscriber joins after the Multi has completed (or failed), then it won\u2019t receive any item. This is where replaying can be useful.","title":"Replaying Multis"},{"location":"guides/replaying-multis/#replaying-all-events","text":"Replaying all events from an upstream Multi works as follows: 1 2 3 4 5 6 Multi < Integer > upstream = Multi . createFrom (). range ( 0 , 10 ); Multi < Integer > replay = Multi . createBy (). replaying (). ofMulti ( upstream ); List < Integer > items_1 = replay . collect (). asList (). await (). indefinitely (); List < Integer > items_2 = replay . collect (). asList (). await (). indefinitely (); Both item_1 and item_2 trigger new subscriptions, and both lists contain the following elements: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] Replaying works by turning upstream into a hot-stream , meaning that it gets requested Long.MAX_VALUE elements. This is done when the first subscription happens. The replay operator stores the items in an internal replay log , and then each subscriber gets to replay them. Important Subscribers demand and cancellation requests are honored while replaying, but upstream cannot be cancelled. Be careful with unbounded streams as you can exhaust memory! In such cases or when you need to replay large amounts of data, you might opt to use some eventing middleware rather than Mutiny replays.","title":"Replaying all events"},{"location":"guides/replaying-multis/#replaying-the-last-n-events","text":"You can limit the number of elements to replay by using the upTo method: 1 2 3 4 5 6 Multi < Integer > upstream = Multi . createFrom (). range ( 0 , 10 ); Multi < Integer > replay = Multi . createBy (). replaying (). upTo ( 3 ). ofMulti ( upstream ); List < Integer > items_1 = replay . collect (). asList (). await (). indefinitely (); List < Integer > items_2 = replay . collect (). asList (). await (). indefinitely (); Each new subscriber gets to replay the last n elements from where the replay log is at subscription time. For instance the first subscriber can observe all events, while a subscriber that joins 2 seconds later might not observe the earlier events. Since Multi.createFrom().range(0, 10) is an immediate stream, both item_1 and item_2 lists contain the last items: [7, 8, 9]","title":"Replaying the last 'n' events"},{"location":"guides/replaying-multis/#prepending-with-seed-data","text":"In some cases you might want to prepend some seed data that will be available for replay before the upstream starts emitting. You can do so using an Iterable to provide such seed data: 1 2 3 4 5 6 7 Multi < Integer > upstream = Multi . createFrom (). range ( 0 , 10 ); Iterable < Integer > seed = Arrays . asList ( - 10 , - 5 , - 1 ); Multi < Integer > replay = Multi . createBy (). replaying (). ofSeedAndMulti ( seed , upstream ); List < Integer > items_1 = replay . collect (). asList (). await (). indefinitely (); List < Integer > items_2 = replay . collect (). asList (). await (). indefinitely (); In which case subscribers can observe the following events: [-10, -5, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]","title":"Prepending with seed data"},{"location":"guides/replaying-multis/#replay-of-failures-and-completions","text":"Subscribers get to observe not just items but also the failure and completion events: 1 2 3 4 5 6 7 8 9 10 11 Multi < Integer > upstream = Multi . createBy (). concatenating (). streams ( Multi . createFrom (). range ( 0 , 10 ), Multi . createFrom (). failure (() -> new IOException ( \"boom\" )) ); Multi < Integer > replay = Multi . createBy (). replaying (). upTo ( 3 ). ofMulti ( upstream ); replay . subscribe (). with ( n -> System . out . println ( \" -> \" + n ), failure -> System . out . println ( \"Failed: \" + failure . getMessage ()), () -> System . out . println ( \"Completed\" )); Running this code yields the following output for any subscriber: -> 7 -> 8 -> 9 Failed: boom","title":"Replay of failures and completions"},{"location":"guides/rx/","tags":["guide","advanced"],"text":"Using map, flatMap and concatMap # If you are a seasoned reactive developer, you may miss the map , flatMap , concatMap methods. The Mutiny API is quite different from the standard reactive eXtensions API. There are multiple reasons for this choice. Typically, flatMap is not necessarily well understood by every developer, leading to potentially catastrophic consequences. That being said, Mutiny provides the map , flatMap and concatMap methods, implementing the most common variant for each: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int result = uni . map ( i -> i + 1 ) . await (). indefinitely (); int result2 = uni . flatMap ( i -> Uni . createFrom (). item ( i + 1 )) . await (). indefinitely (); List < Integer > list = multi . map ( i -> i + 1 ) . collect (). asList () . await (). indefinitely (); List < Integer > list2 = multi . flatMap ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); List < Integer > list3 = multi . concatMap ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); The Mutiny equivalents are: map -> onItem().transform() flatMap -> onItem().transformToUniAndMerge and onItem().transformToMultiAndMerge concatMap -> onItem().transformToUniAndConcatenate and onItem().transformToMultiAndConcatenate The following snippet demonstrates how to uses these methods: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int result = uni . onItem (). transform ( i -> i + 1 ) . await (). indefinitely (); int result2 = uni . onItem (). transformToUni ( i -> Uni . createFrom (). item ( i + 1 )) . await (). indefinitely (); // Shortcut for .onItem().transformToUni int result3 = uni . chain ( i -> Uni . createFrom (). item ( i + 1 )) . await (). indefinitely (); List < Integer > list = multi . onItem (). transform ( i -> i + 1 ) . collect (). asList () . await (). indefinitely (); List < Integer > list2 = multi . onItem (). transformToMultiAndMerge ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); // Equivalent to transformToMultiAndMerge but let you configure the flattening process, // failure management, concurrency... List < Integer > list3 = multi . onItem (). transformToMulti ( i -> Multi . createFrom (). items ( i , i )). merge () . collect (). asList () . await (). indefinitely (); List < Integer > list4 = multi . onItem (). transformToMultiAndConcatenate ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); // Equivalent to transformToMultiAndConcatenate but let you configure the flattening process, // failure management... List < Integer > list5 = multi . onItem (). transformToMulti ( i -> Multi . createFrom (). items ( i , i )). concatenate () . collect (). asList () . await (). indefinitely ();","title":"Using map, flatMap and concatMap"},{"location":"guides/rx/#using-map-flatmap-and-concatmap","text":"If you are a seasoned reactive developer, you may miss the map , flatMap , concatMap methods. The Mutiny API is quite different from the standard reactive eXtensions API. There are multiple reasons for this choice. Typically, flatMap is not necessarily well understood by every developer, leading to potentially catastrophic consequences. That being said, Mutiny provides the map , flatMap and concatMap methods, implementing the most common variant for each: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int result = uni . map ( i -> i + 1 ) . await (). indefinitely (); int result2 = uni . flatMap ( i -> Uni . createFrom (). item ( i + 1 )) . await (). indefinitely (); List < Integer > list = multi . map ( i -> i + 1 ) . collect (). asList () . await (). indefinitely (); List < Integer > list2 = multi . flatMap ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); List < Integer > list3 = multi . concatMap ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); The Mutiny equivalents are: map -> onItem().transform() flatMap -> onItem().transformToUniAndMerge and onItem().transformToMultiAndMerge concatMap -> onItem().transformToUniAndConcatenate and onItem().transformToMultiAndConcatenate The following snippet demonstrates how to uses these methods: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int result = uni . onItem (). transform ( i -> i + 1 ) . await (). indefinitely (); int result2 = uni . onItem (). transformToUni ( i -> Uni . createFrom (). item ( i + 1 )) . await (). indefinitely (); // Shortcut for .onItem().transformToUni int result3 = uni . chain ( i -> Uni . createFrom (). item ( i + 1 )) . await (). indefinitely (); List < Integer > list = multi . onItem (). transform ( i -> i + 1 ) . collect (). asList () . await (). indefinitely (); List < Integer > list2 = multi . onItem (). transformToMultiAndMerge ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); // Equivalent to transformToMultiAndMerge but let you configure the flattening process, // failure management, concurrency... List < Integer > list3 = multi . onItem (). transformToMulti ( i -> Multi . createFrom (). items ( i , i )). merge () . collect (). asList () . await (). indefinitely (); List < Integer > list4 = multi . onItem (). transformToMultiAndConcatenate ( i -> Multi . createFrom (). items ( i , i )) . collect (). asList () . await (). indefinitely (); // Equivalent to transformToMultiAndConcatenate but let you configure the flattening process, // failure management... List < Integer > list5 = multi . onItem (). transformToMulti ( i -> Multi . createFrom (). items ( i , i )). concatenate () . collect (). asList () . await (). indefinitely ();","title":"Using map, flatMap and concatMap"},{"location":"guides/shortcut-methods/","tags":["guide","beginner"],"text":"Shortcut methods # The Mutiny API is decomposed around the idea of groups, each group handling a specific event. However, to avoid verbosity, Mutiny also exposes shortcuts for the most used methods. Be aware that these shorts, while making the code shorter, may harm the readability and understandability. To peek at items, you can use the invoke method: 1 2 Multi < String > multi = Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ); multi . invoke ( item -> System . out . println ( \"Received item \" + item )); invoke is a shortcut for onItem().invoke(...) . Mutiny also provides the call method for executing an action returning a Uni . This is useful to execute an asynchronous action without modifying incoming item: 1 multi . call ( item -> executeAnAsyncAction ( item )); call is a shortcut for onItem().call(...) . The following table lists the available shortcuts available by the Uni class: Shortcut Equivalent uni.map(x -> y) uni.onItem().transform(x -> y) uni.flatMap(x -> uni2) uni.onItem().transformToUni(x -> uni2) uni.chain(x -> uni2) uni.onItem().transformToUni(x -> uni2) uni.then(() -> uni2) uni.onItem().transformToUni(ignored -> uni2) uni.invoke(x -> System.out.println(x)) uni.onItem().invoke(x -> System.out.println(x)) uni.call(x -> uni2) uni.onItem().call(x -> uni2) uni.eventually(() -> System.out.println(\"eventually\")) uni.onItemOrFailure().invoke((ignoredItem, ignoredException) -> System.out.println(\"eventually\")) uni.eventually(() -> uni2) uni.onItemOrFailure().call((ignoredItem, ignoredException) -> uni2) uni.replaceWith(x) uni.onItem().transform(ignored -> x) uni.replaceWith(uni2) uni.onItem().transformToUni(ignored -> uni2) uni.replaceIfNullWith(x) uni.onItem().ifNull().continueWith(x)","title":"Shortcut methods"},{"location":"guides/shortcut-methods/#shortcut-methods","text":"The Mutiny API is decomposed around the idea of groups, each group handling a specific event. However, to avoid verbosity, Mutiny also exposes shortcuts for the most used methods. Be aware that these shorts, while making the code shorter, may harm the readability and understandability. To peek at items, you can use the invoke method: 1 2 Multi < String > multi = Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ); multi . invoke ( item -> System . out . println ( \"Received item \" + item )); invoke is a shortcut for onItem().invoke(...) . Mutiny also provides the call method for executing an action returning a Uni . This is useful to execute an asynchronous action without modifying incoming item: 1 multi . call ( item -> executeAnAsyncAction ( item )); call is a shortcut for onItem().call(...) . The following table lists the available shortcuts available by the Uni class: Shortcut Equivalent uni.map(x -> y) uni.onItem().transform(x -> y) uni.flatMap(x -> uni2) uni.onItem().transformToUni(x -> uni2) uni.chain(x -> uni2) uni.onItem().transformToUni(x -> uni2) uni.then(() -> uni2) uni.onItem().transformToUni(ignored -> uni2) uni.invoke(x -> System.out.println(x)) uni.onItem().invoke(x -> System.out.println(x)) uni.call(x -> uni2) uni.onItem().call(x -> uni2) uni.eventually(() -> System.out.println(\"eventually\")) uni.onItemOrFailure().invoke((ignoredItem, ignoredException) -> System.out.println(\"eventually\")) uni.eventually(() -> uni2) uni.onItemOrFailure().call((ignoredItem, ignoredException) -> uni2) uni.replaceWith(x) uni.onItem().transform(ignored -> x) uni.replaceWith(uni2) uni.onItem().transformToUni(ignored -> uni2) uni.replaceIfNullWith(x) uni.onItem().ifNull().continueWith(x)","title":"Shortcut methods"},{"location":"guides/spies/","tags":["guide","advanced"],"text":"Spying on events # Spies are useful when you need to track which events flow into a Uni or a Multi . Spies can track events from groups such as onItem() , onFailure() , onSubscribe() , etc. The io.smallrye.mutiny.helpers.spies.Spy interface offers factory methods to spy on selected groups, or even on all groups. Spying selected groups # The following example spies on requests and completion group events: 1 2 3 4 5 6 7 8 Multi < Integer > multi = Multi . createFrom (). items ( 1 , 2 , 3 ); MultiOnRequestSpy < Integer > requestSpy = Spy . onRequest ( multi ); MultiOnCompletionSpy < Integer > completionSpy = Spy . onCompletion ( requestSpy ); completionSpy . subscribe (). with ( System . out :: println ); System . out . println ( \"Number of requests: \" + requestSpy . requestedCount ()); System . out . println ( \"Completed? \" + completionSpy . invoked ()); The standard output stream shall display the following text: 1 2 3 Number of requests: 9223372036854775807 Completed? true The number of requests corresponds to Long.MAX_VALUE , and a completion event was sent. Important It is important to note that spies observe and report events for all subscribers, not just one in particular. You should call the .reset() method on a given spy to resets its statistics such as the invocation count. Spying all groups # You can take advantage of a global spy if you are interested in all event groups: 1 2 3 4 5 6 7 8 9 Multi < Integer > multi = Multi . createFrom (). items ( 1 , 2 , 3 ); MultiGlobalSpy < Integer > spy = Spy . globally ( multi ); spy . subscribe (). with ( System . out :: println ); System . out . println ( \"Number of requests: \" + spy . onRequestSpy (). requestedCount ()); System . out . println ( \"Cancelled? \" + spy . onCancellationSpy (). isCancelled ()); System . out . println ( \"Failure? \" + spy . onFailureSpy (). lastFailure ()); System . out . println ( \"Items: \" + spy . onItemSpy (). items ()); Running the snippet above gives the following output: 1 2 3 Number of requests: 9223372036854775807 Cancelled? false Failure? null Items: [1, 2, 3] Warning Tracking onItem() events on a Multi requires storing all items into a list, which can yield an out-of-memory exception with large streams. In such cases consider using Spy.onItem(multi, false) to obtain a spy that does not store items, but that can still report data such as the number of received events (see spy.invocationCount() ).","title":"Spying on events"},{"location":"guides/spies/#spying-on-events","text":"Spies are useful when you need to track which events flow into a Uni or a Multi . Spies can track events from groups such as onItem() , onFailure() , onSubscribe() , etc. The io.smallrye.mutiny.helpers.spies.Spy interface offers factory methods to spy on selected groups, or even on all groups.","title":"Spying on events"},{"location":"guides/spies/#spying-selected-groups","text":"The following example spies on requests and completion group events: 1 2 3 4 5 6 7 8 Multi < Integer > multi = Multi . createFrom (). items ( 1 , 2 , 3 ); MultiOnRequestSpy < Integer > requestSpy = Spy . onRequest ( multi ); MultiOnCompletionSpy < Integer > completionSpy = Spy . onCompletion ( requestSpy ); completionSpy . subscribe (). with ( System . out :: println ); System . out . println ( \"Number of requests: \" + requestSpy . requestedCount ()); System . out . println ( \"Completed? \" + completionSpy . invoked ()); The standard output stream shall display the following text: 1 2 3 Number of requests: 9223372036854775807 Completed? true The number of requests corresponds to Long.MAX_VALUE , and a completion event was sent. Important It is important to note that spies observe and report events for all subscribers, not just one in particular. You should call the .reset() method on a given spy to resets its statistics such as the invocation count.","title":"Spying selected groups"},{"location":"guides/spies/#spying-all-groups","text":"You can take advantage of a global spy if you are interested in all event groups: 1 2 3 4 5 6 7 8 9 Multi < Integer > multi = Multi . createFrom (). items ( 1 , 2 , 3 ); MultiGlobalSpy < Integer > spy = Spy . globally ( multi ); spy . subscribe (). with ( System . out :: println ); System . out . println ( \"Number of requests: \" + spy . onRequestSpy (). requestedCount ()); System . out . println ( \"Cancelled? \" + spy . onCancellationSpy (). isCancelled ()); System . out . println ( \"Failure? \" + spy . onFailureSpy (). lastFailure ()); System . out . println ( \"Items: \" + spy . onItemSpy (). items ()); Running the snippet above gives the following output: 1 2 3 Number of requests: 9223372036854775807 Cancelled? false Failure? null Items: [1, 2, 3] Warning Tracking onItem() events on a Multi requires storing all items into a list, which can yield an out-of-memory exception with large streams. In such cases consider using Spy.onItem(multi, false) to obtain a spy that does not store items, but that can still report data such as the number of received events (see spy.invocationCount() ).","title":"Spying all groups"},{"location":"guides/take-skip-items/","tags":["guide","beginner"],"text":"Take/Skip the first or last items # Multi provides the ability to: only forward items from the beginning of the observed multi, only forward the last items (and discard all the other ones), skip items from the beginning of the multi, skip the last items. These actions are available from the multi.select() and multi.skip() groups, allowing to, respectively, select and skip items from upstream. Selecting items # The multi.select().first method forwards on the n first items from the multi. It forwards that amount of items and then sends the completion signal. It also cancels the upstream subscription. 1 Multi < Integer > firstThreeItems = multi . select (). first ( 3 ); Note The select().first() method selects only the first item. If the observed multi emits fewer items, it sends the completion event when the upstream completes. Similarly, The multi.select().last operator forwards on the n last items from the multi. It discards all the items emitted beforehand. 1 Multi < Integer > lastThreeItems = multi . select (). last ( 3 ); Note The select().last() method selects only the last item. The multi.select().first(Predicate) operator forwards the items while the passed predicate returns true : 1 Multi < Integer > takeWhile = multi . select (). first ( i -> i < 4 ); It calls the predicate for each item. Once the predicate returns false , it stops forwarding the items downstream. It also sends the completion event and cancels the upstream subscription. Finally, multi.select().first(Duration) operator picks the first items emitted during a given period. Once the passed duration expires, it sends the completion event and cancels the upstream subscription. If the observed multi completes before the passed duration, it sends the completion event. 1 Multi < Integer > takeForDuration = multi . select (). first ( Duration . ofSeconds ( 1 )); Skipping items # You can also skip items using multi.skip() . The multi.skip().first(n) method skips the n first items from the multi. It forwards all the remaining items and sends the completion event when the upstream multi completes. 1 Multi < Integer > skipThreeItems = multi . skip (). first ( 3 ); If the observed multi emits fewer items, it sends the completion event without emitting any items. Note skip().last() drops only the very last item. Similarly, The multi.skip().last(n) operator skips on the n last items from the multi: 1 Multi < Integer > skipLastThreeItems = multi . skip (). last ( 3 ); The multi.skip().first(Predicate) operator skips the items while the passed predicate returns true : 1 Multi < Integer > skipWhile = multi . skip (). first ( i -> i < 4 ); It calls the predicate for each item. Once the predicate returns false , it stops discarding the items and starts forwarding downstream. Finally, multi.skip().first(Duration) operator skips the first items for a given period. Once the passed duration expires, it sends the items emitted after the deadline downstream. If the observed multi completes before the passed duration, it sends the completion event. 1 Multi < Integer > skipForDuration = multi . skip (). first ( Duration . ofSeconds ( 1 ));","title":"Take/Skip the first or last items"},{"location":"guides/take-skip-items/#takeskip-the-first-or-last-items","text":"Multi provides the ability to: only forward items from the beginning of the observed multi, only forward the last items (and discard all the other ones), skip items from the beginning of the multi, skip the last items. These actions are available from the multi.select() and multi.skip() groups, allowing to, respectively, select and skip items from upstream.","title":"Take/Skip the first or last items"},{"location":"guides/take-skip-items/#selecting-items","text":"The multi.select().first method forwards on the n first items from the multi. It forwards that amount of items and then sends the completion signal. It also cancels the upstream subscription. 1 Multi < Integer > firstThreeItems = multi . select (). first ( 3 ); Note The select().first() method selects only the first item. If the observed multi emits fewer items, it sends the completion event when the upstream completes. Similarly, The multi.select().last operator forwards on the n last items from the multi. It discards all the items emitted beforehand. 1 Multi < Integer > lastThreeItems = multi . select (). last ( 3 ); Note The select().last() method selects only the last item. The multi.select().first(Predicate) operator forwards the items while the passed predicate returns true : 1 Multi < Integer > takeWhile = multi . select (). first ( i -> i < 4 ); It calls the predicate for each item. Once the predicate returns false , it stops forwarding the items downstream. It also sends the completion event and cancels the upstream subscription. Finally, multi.select().first(Duration) operator picks the first items emitted during a given period. Once the passed duration expires, it sends the completion event and cancels the upstream subscription. If the observed multi completes before the passed duration, it sends the completion event. 1 Multi < Integer > takeForDuration = multi . select (). first ( Duration . ofSeconds ( 1 ));","title":"Selecting items"},{"location":"guides/take-skip-items/#skipping-items","text":"You can also skip items using multi.skip() . The multi.skip().first(n) method skips the n first items from the multi. It forwards all the remaining items and sends the completion event when the upstream multi completes. 1 Multi < Integer > skipThreeItems = multi . skip (). first ( 3 ); If the observed multi emits fewer items, it sends the completion event without emitting any items. Note skip().last() drops only the very last item. Similarly, The multi.skip().last(n) operator skips on the n last items from the multi: 1 Multi < Integer > skipLastThreeItems = multi . skip (). last ( 3 ); The multi.skip().first(Predicate) operator skips the items while the passed predicate returns true : 1 Multi < Integer > skipWhile = multi . skip (). first ( i -> i < 4 ); It calls the predicate for each item. Once the predicate returns false , it stops discarding the items and starts forwarding downstream. Finally, multi.skip().first(Duration) operator skips the first items for a given period. Once the passed duration expires, it sends the items emitted after the deadline downstream. If the observed multi completes before the passed duration, it sends the completion event. 1 Multi < Integer > skipForDuration = multi . skip (). first ( Duration . ofSeconds ( 1 ));","title":"Skipping items"},{"location":"guides/testing/","tags":["guide","beginner"],"text":"How can I write unit / integration tests? # Mutiny provides subscribers for Uni and Multi offering helpful assertion methods. You can use them to test pipelines. Here is an example to test a Uni : 1 2 3 4 5 6 7 8 Uni < Integer > uni = Uni . createFrom (). item ( 63 ); UniAssertSubscriber < Integer > subscriber = uni . subscribe (). withSubscriber ( UniAssertSubscriber . create ()); subscriber . awaitItem () . assertItem ( 63 ); Testing a Multi pipeline is similar: 1 2 3 4 5 6 7 8 Multi < Integer > multi = Multi . createFrom (). range ( 1 , 5 ) . onItem (). transform ( n -> n * 10 ); AssertSubscriber < Integer > subscriber = multi . subscribe (). withSubscriber ( AssertSubscriber . create ( 10 )); subscriber . awaitCompletion () . assertItems ( 10 , 20 , 30 , 40 ); The assertions do not just focus on good outcomes, you can also test failures as in: 1 2 3 4 5 6 7 8 Multi < Object > multi = Multi . createFrom (). failure (() -> new IOException ( \"Boom\" )); AssertSubscriber < Object > subscriber = multi . subscribe (). withSubscriber ( AssertSubscriber . create ( 10 )); subscriber . awaitFailure () . assertFailedWith ( IOException . class , \"Boom\" );","title":"How can I write unit / integration tests?"},{"location":"guides/testing/#how-can-i-write-unit-integration-tests","text":"Mutiny provides subscribers for Uni and Multi offering helpful assertion methods. You can use them to test pipelines. Here is an example to test a Uni : 1 2 3 4 5 6 7 8 Uni < Integer > uni = Uni . createFrom (). item ( 63 ); UniAssertSubscriber < Integer > subscriber = uni . subscribe (). withSubscriber ( UniAssertSubscriber . create ()); subscriber . awaitItem () . assertItem ( 63 ); Testing a Multi pipeline is similar: 1 2 3 4 5 6 7 8 Multi < Integer > multi = Multi . createFrom (). range ( 1 , 5 ) . onItem (). transform ( n -> n * 10 ); AssertSubscriber < Integer > subscriber = multi . subscribe (). withSubscriber ( AssertSubscriber . create ( 10 )); subscriber . awaitCompletion () . assertItems ( 10 , 20 , 30 , 40 ); The assertions do not just focus on good outcomes, you can also test failures as in: 1 2 3 4 5 6 7 8 Multi < Object > multi = Multi . createFrom (). failure (() -> new IOException ( \"Boom\" )); AssertSubscriber < Object > subscriber = multi . subscribe (). withSubscriber ( AssertSubscriber . create ( 10 )); subscriber . awaitFailure () . assertFailedWith ( IOException . class , \"Boom\" );","title":"How can I write unit / integration tests?"},{"location":"guides/unchecked-exceptions/","tags":["guide","intermediate"],"text":"Dealing with checked exceptions # When implementing your reactive pipeline, you write lots of functions ( java.util.function.Function ), consumers ( java.util.function.Consumer ), suppliers ( java.util.function.Supplier ) and so on. By default, you cannot throw checked exceptions. When integrating libraries throwing checked exceptions (like IOException ) it\u2019s not very convenient to add a try/catch block and wrap the thrown exception into a runtime exception: 1 2 3 4 5 6 7 Uni < Integer > uni = item . onItem (). transform ( i -> { try { return methodThrowingIoException ( i ); } catch ( IOException e ) { throw new UncheckedIOException ( e ); } }); Mutiny provides utilities to avoid having to do this manually. If your operation throws a checked exception , you can use the io.smallrye.mutiny.unchecked.Unchecked wrappers. For example, if your synchronous transformation uses a method throwing a checked exception, wrap it using Unchecked.function : 1 2 3 4 Uni < Integer > uni = item . onItem (). transform ( Unchecked . function ( i -> { // Can throw checked exception return methodThrowingIoException ( i ); })); You can also wrap consumers such as in: 1 2 3 4 Uni < Integer > uni = item . onItem (). invoke ( Unchecked . consumer ( i -> { // Can throw checked exception throw new IOException ( \"boom\" ); })); Tip You can add the following import statement to simplify the usage of the provided methods: import static io.smallrye.mutiny.unchecked.Unchecked.*;","title":"Dealing with checked exceptions"},{"location":"guides/unchecked-exceptions/#dealing-with-checked-exceptions","text":"When implementing your reactive pipeline, you write lots of functions ( java.util.function.Function ), consumers ( java.util.function.Consumer ), suppliers ( java.util.function.Supplier ) and so on. By default, you cannot throw checked exceptions. When integrating libraries throwing checked exceptions (like IOException ) it\u2019s not very convenient to add a try/catch block and wrap the thrown exception into a runtime exception: 1 2 3 4 5 6 7 Uni < Integer > uni = item . onItem (). transform ( i -> { try { return methodThrowingIoException ( i ); } catch ( IOException e ) { throw new UncheckedIOException ( e ); } }); Mutiny provides utilities to avoid having to do this manually. If your operation throws a checked exception , you can use the io.smallrye.mutiny.unchecked.Unchecked wrappers. For example, if your synchronous transformation uses a method throwing a checked exception, wrap it using Unchecked.function : 1 2 3 4 Uni < Integer > uni = item . onItem (). transform ( Unchecked . function ( i -> { // Can throw checked exception return methodThrowingIoException ( i ); })); You can also wrap consumers such as in: 1 2 3 4 Uni < Integer > uni = item . onItem (). invoke ( Unchecked . consumer ( i -> { // Can throw checked exception throw new IOException ( \"boom\" ); })); Tip You can add the following import statement to simplify the usage of the provided methods: import static io.smallrye.mutiny.unchecked.Unchecked.*;","title":"Dealing with checked exceptions"},{"location":"reference/migrating-to-mutiny-2/","tags":["reference","beginner"],"text":"Migrating to Mutiny 2 # The upgrade is transparent for most code bases that use Mutiny in applications (e.g., Quarkus applications). Highlights # Mutiny 2 is a major release with source and binary incompatible changes to the Mutiny 0.x and 1.x series. The main highlight of Mutiny 2 is that it is now based on top of the java.util.concurrent.Flow APIs instead of the legacy Reactive Streams APIs . The Flow APIs have been part of the JDK since Java 9, and they are the modern Reactive Streams APIs . Mutiny remains a faithful implementation of the Reactive Streams specification and passes the Flow variant of the Reactive Streams TCK . Deprecated APIs in Mutiny 1.x have been removed, and experimental APIs have been promoted. Impact of the switch from legacy Reactive Streams APIs to JDK Flow # The Flow types are isomorphic to the legacy Reactive Streams API types. We recommend that you migrate to Flow in your own code bases. You should encourage third-party libraries to migrate to Flow . You can always use adapters to go back and forth between Flow and legacy Reactive Streams types. General guidelines # If your code only uses Uni and Multi (i.e., not org.reactivestreams.Publisher ), then you will be source-compatible with Mutiny 2. You should still recompile and check that your test suites pass. If you expose Multi as a org.reactivestreams.Publisher then you will either need an adapter (see below) or migrate to java.util.concurrent.Flow.Publisher . If you interact with org.reactivestreams.Publisher publishers and you can\u2019t migrate them to java.util.concurrent.Flow.Publisher (e.g., because it is a third-party library), then you will need an adapter . Please encourage third-party libraries to migrate to Flow . Adapters between Flow and legacy Reactive Streams APIs # We recommend using the adapters from the Mutiny Zero project . The Maven coordinates are groupId: io.smallrye.reactive , artifactId: mutiny-zero-flow-adapters Use AdaptersToFlow to convert from Reactive Streams types to Flow types, and Use AdaptersToReactiveStreams to convert Flow types to Reactive Streams types. The Mutiny Zero adapters have virtually zero overhead. Other API changes # Deprecated API removals # Uni and Multi onSubscribe() group is now onSubscription() . AssertSubscriber.await() has been replaced by event-specific methods (items, failure, completion, etc). The RxJava 2 integration module has been discarded (only RxJava 3 is now supported). Experimental API promotions # Uni and Multi subscription-bound contexts. Uni.join() publisher. .ifNoItem() timeout operators. Uni and Multi spies. capDemandsUsing() and paceDemand() request management operators. Multi replay() operator.","title":"Migrating to Mutiny 2"},{"location":"reference/migrating-to-mutiny-2/#migrating-to-mutiny-2","text":"The upgrade is transparent for most code bases that use Mutiny in applications (e.g., Quarkus applications).","title":"Migrating to Mutiny 2"},{"location":"reference/migrating-to-mutiny-2/#highlights","text":"Mutiny 2 is a major release with source and binary incompatible changes to the Mutiny 0.x and 1.x series. The main highlight of Mutiny 2 is that it is now based on top of the java.util.concurrent.Flow APIs instead of the legacy Reactive Streams APIs . The Flow APIs have been part of the JDK since Java 9, and they are the modern Reactive Streams APIs . Mutiny remains a faithful implementation of the Reactive Streams specification and passes the Flow variant of the Reactive Streams TCK . Deprecated APIs in Mutiny 1.x have been removed, and experimental APIs have been promoted.","title":"Highlights"},{"location":"reference/migrating-to-mutiny-2/#impact-of-the-switch-from-legacy-reactive-streams-apis-to-jdk-flow","text":"The Flow types are isomorphic to the legacy Reactive Streams API types. We recommend that you migrate to Flow in your own code bases. You should encourage third-party libraries to migrate to Flow . You can always use adapters to go back and forth between Flow and legacy Reactive Streams types.","title":"Impact of the switch from legacy Reactive Streams APIs to JDK Flow"},{"location":"reference/migrating-to-mutiny-2/#general-guidelines","text":"If your code only uses Uni and Multi (i.e., not org.reactivestreams.Publisher ), then you will be source-compatible with Mutiny 2. You should still recompile and check that your test suites pass. If you expose Multi as a org.reactivestreams.Publisher then you will either need an adapter (see below) or migrate to java.util.concurrent.Flow.Publisher . If you interact with org.reactivestreams.Publisher publishers and you can\u2019t migrate them to java.util.concurrent.Flow.Publisher (e.g., because it is a third-party library), then you will need an adapter . Please encourage third-party libraries to migrate to Flow .","title":"General guidelines"},{"location":"reference/migrating-to-mutiny-2/#adapters-between-flow-and-legacy-reactive-streams-apis","text":"We recommend using the adapters from the Mutiny Zero project . The Maven coordinates are groupId: io.smallrye.reactive , artifactId: mutiny-zero-flow-adapters Use AdaptersToFlow to convert from Reactive Streams types to Flow types, and Use AdaptersToReactiveStreams to convert Flow types to Reactive Streams types. The Mutiny Zero adapters have virtually zero overhead.","title":"Adapters between Flow and legacy Reactive Streams APIs"},{"location":"reference/migrating-to-mutiny-2/#other-api-changes","text":"","title":"Other API changes"},{"location":"reference/migrating-to-mutiny-2/#deprecated-api-removals","text":"Uni and Multi onSubscribe() group is now onSubscription() . AssertSubscriber.await() has been replaced by event-specific methods (items, failure, completion, etc). The RxJava 2 integration module has been discarded (only RxJava 3 is now supported).","title":"Deprecated API removals"},{"location":"reference/migrating-to-mutiny-2/#experimental-api-promotions","text":"Uni and Multi subscription-bound contexts. Uni.join() publisher. .ifNoItem() timeout operators. Uni and Multi spies. capDemandsUsing() and paceDemand() request management operators. Multi replay() operator.","title":"Experimental API promotions"},{"location":"reference/publications/","tags":["reference","advanced"],"text":"Publications # Julien Ponge, Arthur Navarro, Cl\u00e9ment Escoffier, and Fr\u00e9d\u00e9ric Le Mou\u00ebl. 2021. Analysing the Performance and Costs of Reactive Programming Libraries in Java . In Proceedings of the 8 th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems (REBLS \u201921) , October 18, 2021, Chicago, IL, USA. ACM, New York, NY, USA, 10 pages. (PDF) Modern services running in cloud and edge environments need to be resource-efficient to increase deployment density and reduce operating costs. Asynchronous I/O combined with asynchronous programming provides a solid technical foundation to reach these goals. Reactive programming and reactive streams are gaining traction in the Java ecosystem. However, reactive streams implementations tend to be complex to work with and maintain. This paper discusses the performance of the three major reactive streams compliant libraries used in Java applications: RxJava, Project Reactor, and SmallRye Mutiny. As we will show, advanced optimization techniques such as operator fusion do not yield better performance on realistic I/O-bound workloads, and they significantly increase development and maintenance costs.","title":"Publications"},{"location":"reference/publications/#publications","text":"Julien Ponge, Arthur Navarro, Cl\u00e9ment Escoffier, and Fr\u00e9d\u00e9ric Le Mou\u00ebl. 2021. Analysing the Performance and Costs of Reactive Programming Libraries in Java . In Proceedings of the 8 th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems (REBLS \u201921) , October 18, 2021, Chicago, IL, USA. ACM, New York, NY, USA, 10 pages. (PDF) Modern services running in cloud and edge environments need to be resource-efficient to increase deployment density and reduce operating costs. Asynchronous I/O combined with asynchronous programming provides a solid technical foundation to reach these goals. Reactive programming and reactive streams are gaining traction in the Java ecosystem. However, reactive streams implementations tend to be complex to work with and maintain. This paper discusses the performance of the three major reactive streams compliant libraries used in Java applications: RxJava, Project Reactor, and SmallRye Mutiny. As we will show, advanced optimization techniques such as operator fusion do not yield better performance on realistic I/O-bound workloads, and they significantly increase development and maintenance costs.","title":"Publications"},{"location":"reference/uni-and-multi/","tags":["reference","beginner"],"text":"Uni and Multi # Mutiny defines two reactive types: Multi - represents streams of 0..* items (potentially unbounded) Uni - represents streams receiving either an item or a failure Tip The Mutiny name comes from the contraction of Multi and Uni names Both Uni and Multi are asynchronous types. They receive and fire events at any time. You may wonder why we make the distinction between Uni and Multi. Conceptually, a Uni is a Multi, right? In practice, you don\u2019t use Unis and Multis the same way. The use cases and operations are different. Uni does not need the complete ceremony presented above as the request does not make sense. The subscribe event expresses the interest and triggers the computation, no need for an additional request . Uni can handle items having a null value (and has specific methods to handle this case). Multi does not allow it (because the Reactive Streams specification forbids it). Having a Uni implementing Publisher would be a bit like having Optional implementing Iterable . In other words, Uni : can receive at most 1 item event, or a failure event cannot receive a completion event ( null in the case of 0 items) cannot receive a request event The following snippet shows how you can use Uni and Multi : 1 2 3 4 5 6 7 8 9 10 11 12 13 Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ) . onItem (). transform ( String :: toUpperCase ) . subscribe (). with ( item -> System . out . println ( \"Received: \" + item ), failure -> System . out . println ( \"Failed with \" + failure ) ); Uni . createFrom (). item ( \"a\" ) . onItem (). transform ( String :: toUpperCase ) . subscribe (). with ( item -> System . out . println ( \"Received: \" + item ), failure -> System . out . println ( \"Failed with \" + failure ) );","title":"Uni and Multi"},{"location":"reference/uni-and-multi/#uni-and-multi","text":"Mutiny defines two reactive types: Multi - represents streams of 0..* items (potentially unbounded) Uni - represents streams receiving either an item or a failure Tip The Mutiny name comes from the contraction of Multi and Uni names Both Uni and Multi are asynchronous types. They receive and fire events at any time. You may wonder why we make the distinction between Uni and Multi. Conceptually, a Uni is a Multi, right? In practice, you don\u2019t use Unis and Multis the same way. The use cases and operations are different. Uni does not need the complete ceremony presented above as the request does not make sense. The subscribe event expresses the interest and triggers the computation, no need for an additional request . Uni can handle items having a null value (and has specific methods to handle this case). Multi does not allow it (because the Reactive Streams specification forbids it). Having a Uni implementing Publisher would be a bit like having Optional implementing Iterable . In other words, Uni : can receive at most 1 item event, or a failure event cannot receive a completion event ( null in the case of 0 items) cannot receive a request event The following snippet shows how you can use Uni and Multi : 1 2 3 4 5 6 7 8 9 10 11 12 13 Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ) . onItem (). transform ( String :: toUpperCase ) . subscribe (). with ( item -> System . out . println ( \"Received: \" + item ), failure -> System . out . println ( \"Failed with \" + failure ) ); Uni . createFrom (). item ( \"a\" ) . onItem (). transform ( String :: toUpperCase ) . subscribe (). with ( item -> System . out . println ( \"Received: \" + item ), failure -> System . out . println ( \"Failed with \" + failure ) );","title":"Uni and Multi"},{"location":"reference/what-is-reactive-programming/","tags":["reference","beginner"],"text":"What is Reactive Programming? # Mutiny is a reactive programming library. If you look on Wikipedia for reactive programming, you will find the following definition: Reactive Programming combines functional programming, the observer pattern, and the iterable pattern. While correct, we never found this definition very helpful. It does not convey clearly what\u2019s reactive programming is all about. So, let\u2019s make another definition, much more straightforward: Reactive programming is about programming with data streams. That\u2019s it. Reactive programming is about streams and especially, observing them. It pushes that idea to its limit: with reactive programming, everything is a data stream. With reactive programming, you observe streams and implement side effects when something flows in the stream: sequenceDiagram participant S1 as Stream participant O1 as Observer participant S2 as Stream participant O2 as Observer S1->>O1: onItem(\"a\") S2->>O2: onItem(\"a\") S1->>O1: onItem(\"b\") S2->>O2: onItem(\"b\") S2->>O2: onItem(\"c\") S1-XO1: onFailure(err) S2->>O2: onCompletion() It\u2019s asynchronous by nature as you don\u2019t know when the data is going to be seen. Yet, reactive programming goes beyond this. It provides a toolbox to compose streams and process events.","title":"What is Reactive Programming?"},{"location":"reference/what-is-reactive-programming/#what-is-reactive-programming","text":"Mutiny is a reactive programming library. If you look on Wikipedia for reactive programming, you will find the following definition: Reactive Programming combines functional programming, the observer pattern, and the iterable pattern. While correct, we never found this definition very helpful. It does not convey clearly what\u2019s reactive programming is all about. So, let\u2019s make another definition, much more straightforward: Reactive programming is about programming with data streams. That\u2019s it. Reactive programming is about streams and especially, observing them. It pushes that idea to its limit: with reactive programming, everything is a data stream. With reactive programming, you observe streams and implement side effects when something flows in the stream: sequenceDiagram participant S1 as Stream participant O1 as Observer participant S2 as Stream participant O2 as Observer S1->>O1: onItem(\"a\") S2->>O2: onItem(\"a\") S1->>O1: onItem(\"b\") S2->>O2: onItem(\"b\") S2->>O2: onItem(\"c\") S1-XO1: onFailure(err) S2->>O2: onCompletion() It\u2019s asynchronous by nature as you don\u2019t know when the data is going to be seen. Yet, reactive programming goes beyond this. It provides a toolbox to compose streams and process events.","title":"What is Reactive Programming?"},{"location":"reference/what-makes-mutiny-different/","tags":["reference","beginner"],"text":"What makes Mutiny different? # There are other reactive programming libraries out there. In the Java world, we can mention Project Reactor and Rx Java. So, what makes Mutiny different from these two well-known libraries? The API! Asynchronous is hard to grasp for most developers, and for good reasons. Thus, the API must not require advanced knowledge or add cognitive overload. It should help you design your logic and still be intelligible when you return to the code 6 months later. To achieve this, Mutiny is built on three pillars: Event-Driven - with Mutiny, you listen for events and handle them, API Navigability - based on the event-driven nature, the API is built around the type of events and drive the navigation based on the kind of event you want to handle, Simplicity - Mutiny provides only two types ( Multi and Uni ), which can handle any kind of asynchronous interactions. Events? # When you use Mutiny, you design a pipeline in which the events flow. Your code observes these events and react. Each processing stage is a new pipe you append to the pipeline. This pipe may change the events, create new ones, drops, buffers, whatever you need. In general, events flow from upstream to downstream, from source to sinks. Some events can swim upstream from the sinks to the source. Events going from upstream to downstream are published by Publishers and consumed by (downstream) Subscribers, which may also produce events for their own downstream, as illustrated by the following diagram: sequenceDiagram participant P as Publisher participant O1 as Processor 1 participant O2 as Processor 2 participant S as Subscriber P->>O1: onItem O1->>O2: onItem O2->>S: onItem P->>O1: onItem O1->>O2: onItem O2->>S: onItem P->>O1: onCompletion O1->>O2: onCompletion O2->>S: onCompletion Four types of events can flow in this direction: Subscribed - indicates that the upstream has taken into account the subscription - more on this later, Items - events containing some (business) value , Completion - event indicating that the source won\u2019t emit any more items, Failure - event telling that something terrible happened upstream and that the source cannot continue to emit items. Failure and Completion are terminal events. Once they are sent, no more items will flow. Three types of events flow in the opposite direction, i.e. from downstream to upstream: Subscription - event sent by a subscriber to indicate its interest for the events (such as items) emitted by upstream Requests - event sent by a subscriber indicating how many items event it can handle - this is related to back-pressure Cancellation - event sent by a subscriber to stop the reception of events. In a typical scenario: A subscriber subscribes to the upstream - the upstream receive the subscription request , and when initialized sends the subscribed event to the subscriber The subscriber gets the subscribed event with a subscription used to emit the requests and cancellation events The subscriber sends a request event indicating how many items it can handle at this moment; it can request 1, n , or infinite. The publisher receiving the request event starts emitting at most n item events to the subscriber The subscriber can decide at any time to request more events or to cancel the subscription sequenceDiagram participant P as Publisher participant O as Processor participant S as Subscriber S->>O: subscribe O->>P: subscribe P->>O: subscription O->>S: subscription S->>O: request(5) O->>P: request(5) P->>O: onItem(\"a\") O->>S: onItem(\"A\") P->>O: onItem(\"b\") O->>S: onItem(\"B\") S->>O: cancel() O->>P: cancel() The request event is the cornerstone of the back-pressure protocol. A subscriber should not request more than what it can handle, and a publisher should not emit more items than the amount of request received. Note Mutiny uses the Reactive Streams protocol for back-pressure management and the Java Flow APIs . Important Don\u2019t forget to subscribe! If no subscriber subscribes , no items will be emitted. More importantly, nothing will ever happen. If your program does not do anything, check that it subscribes, it\u2019s a very common error. An event-driven API? # Mutiny is an event-driven API. For each type of event, there is an on associated method that lets you handle this specific event. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Multi < String > source = Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ); source . onItem () // Called for every item . invoke ( item -> log ( \"Received item \" + item )) . onFailure () // Called on failure . invoke ( failure -> log ( \"Failed with \" + failure )) . onCompletion () // Called when the stream completes . invoke (() -> log ( \"Completed\" )) . onSubscription () // Called when the upstream is ready . invoke ( subscription -> log ( \"We are subscribed!\" )) . onCancellation () // Called when the downstream cancels . invoke (() -> log ( \"Cancelled :-(\" )) . onRequest () // Called on downstream requests . invoke ( n -> log ( \"Downstream requested \" + n + \" items\" )) . subscribe () . with ( item -> log ( \"Subscriber received \" + item )); Of course, the methods presented in this snippet are not very interesting, although they are quite useful to trace what\u2019s going on. You can see a common pattern emerging: . onEvent (). invoke ( event -> ...); invoke is just one of the methods available. Each group proposes methods specific to the type of event. For example, onFailure().recover , onCompletion().continueWith and so on.","title":"What makes Mutiny different?"},{"location":"reference/what-makes-mutiny-different/#what-makes-mutiny-different","text":"There are other reactive programming libraries out there. In the Java world, we can mention Project Reactor and Rx Java. So, what makes Mutiny different from these two well-known libraries? The API! Asynchronous is hard to grasp for most developers, and for good reasons. Thus, the API must not require advanced knowledge or add cognitive overload. It should help you design your logic and still be intelligible when you return to the code 6 months later. To achieve this, Mutiny is built on three pillars: Event-Driven - with Mutiny, you listen for events and handle them, API Navigability - based on the event-driven nature, the API is built around the type of events and drive the navigation based on the kind of event you want to handle, Simplicity - Mutiny provides only two types ( Multi and Uni ), which can handle any kind of asynchronous interactions.","title":"What makes Mutiny different?"},{"location":"reference/what-makes-mutiny-different/#events","text":"When you use Mutiny, you design a pipeline in which the events flow. Your code observes these events and react. Each processing stage is a new pipe you append to the pipeline. This pipe may change the events, create new ones, drops, buffers, whatever you need. In general, events flow from upstream to downstream, from source to sinks. Some events can swim upstream from the sinks to the source. Events going from upstream to downstream are published by Publishers and consumed by (downstream) Subscribers, which may also produce events for their own downstream, as illustrated by the following diagram: sequenceDiagram participant P as Publisher participant O1 as Processor 1 participant O2 as Processor 2 participant S as Subscriber P->>O1: onItem O1->>O2: onItem O2->>S: onItem P->>O1: onItem O1->>O2: onItem O2->>S: onItem P->>O1: onCompletion O1->>O2: onCompletion O2->>S: onCompletion Four types of events can flow in this direction: Subscribed - indicates that the upstream has taken into account the subscription - more on this later, Items - events containing some (business) value , Completion - event indicating that the source won\u2019t emit any more items, Failure - event telling that something terrible happened upstream and that the source cannot continue to emit items. Failure and Completion are terminal events. Once they are sent, no more items will flow. Three types of events flow in the opposite direction, i.e. from downstream to upstream: Subscription - event sent by a subscriber to indicate its interest for the events (such as items) emitted by upstream Requests - event sent by a subscriber indicating how many items event it can handle - this is related to back-pressure Cancellation - event sent by a subscriber to stop the reception of events. In a typical scenario: A subscriber subscribes to the upstream - the upstream receive the subscription request , and when initialized sends the subscribed event to the subscriber The subscriber gets the subscribed event with a subscription used to emit the requests and cancellation events The subscriber sends a request event indicating how many items it can handle at this moment; it can request 1, n , or infinite. The publisher receiving the request event starts emitting at most n item events to the subscriber The subscriber can decide at any time to request more events or to cancel the subscription sequenceDiagram participant P as Publisher participant O as Processor participant S as Subscriber S->>O: subscribe O->>P: subscribe P->>O: subscription O->>S: subscription S->>O: request(5) O->>P: request(5) P->>O: onItem(\"a\") O->>S: onItem(\"A\") P->>O: onItem(\"b\") O->>S: onItem(\"B\") S->>O: cancel() O->>P: cancel() The request event is the cornerstone of the back-pressure protocol. A subscriber should not request more than what it can handle, and a publisher should not emit more items than the amount of request received. Note Mutiny uses the Reactive Streams protocol for back-pressure management and the Java Flow APIs . Important Don\u2019t forget to subscribe! If no subscriber subscribes , no items will be emitted. More importantly, nothing will ever happen. If your program does not do anything, check that it subscribes, it\u2019s a very common error.","title":"Events?"},{"location":"reference/what-makes-mutiny-different/#an-event-driven-api","text":"Mutiny is an event-driven API. For each type of event, there is an on associated method that lets you handle this specific event. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Multi < String > source = Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ); source . onItem () // Called for every item . invoke ( item -> log ( \"Received item \" + item )) . onFailure () // Called on failure . invoke ( failure -> log ( \"Failed with \" + failure )) . onCompletion () // Called when the stream completes . invoke (() -> log ( \"Completed\" )) . onSubscription () // Called when the upstream is ready . invoke ( subscription -> log ( \"We are subscribed!\" )) . onCancellation () // Called when the downstream cancels . invoke (() -> log ( \"Cancelled :-(\" )) . onRequest () // Called on downstream requests . invoke ( n -> log ( \"Downstream requested \" + n + \" items\" )) . subscribe () . with ( item -> log ( \"Subscriber received \" + item )); Of course, the methods presented in this snippet are not very interesting, although they are quite useful to trace what\u2019s going on. You can see a common pattern emerging: . onEvent (). invoke ( event -> ...); invoke is just one of the methods available. Each group proposes methods specific to the type of event. For example, onFailure().recover , onCompletion().continueWith and so on.","title":"An event-driven API?"},{"location":"reference/why-is-asynchronous-important/","tags":["reference","beginner"],"text":"Why is asynchronous important? # We are living in a distributed world. Most of the applications built nowadays are distributed systems. The Cloud, IoT, microservices, mobile application, even simple CRUD applications are distributed applications. Still, developing distributed systems is hard! Communications in distributed systems are inherently asynchronous and unreliable. Anything can go wrong, anytime, and often with no prior notice. Network disruptions, unavailable services, software, or hardware failures are just a tiny subset of the wide variety of failures that can happen in distributed systems. Correctly building distributed applications is a considerable challenge, as it requires re-assessing almost everything we know from traditional software development. Most classic applications use a synchronous development model. Synchronous code is easy to reason about, more comfortable to write and read than asynchronous code, but it has some hidden cost. This cost emerges when building I/O intensive applications, quite common in distributed applications. In general, these traditional applications assign one thread per request, and so they handle multiple concurrent requests with multiple threads. When the request processing needs to interact over the network, it uses that worker thread, which blocks the thread until the response has been received. This response may never come, so you need to add watchdogs handling timeouts and other resilience patterns. And, to handle more requests concurrently, you need to create more threads. Threads come at a cost. Each thread requires memory, and the more threads you have, the more CPU cycles are used to handle the context switches. Thus, this model ends up being costly, limits the deployment density, and on the Cloud means that you pay bigger bills. Fortunately, there is another way, and it relies on non-blocking I/O, an efficient way to handle I/O interactions that do not require additional threads. While applications using non-blocking I/O are more efficient and better suited for the Cloud\u2019s distributed nature, they come with a considerable constraint: you must never block the I/O thread. Thus, you need to implement your business logic using an asynchronous development model. I/O is not the only reason why asynchronous is essential in Today\u2019s systems. Most of the interactions in the real world are asynchronous and event-driven. Representing these interactions using synchronous processes is not only wrong; it also introduces fragility in your application. Asynchronous is a significant shift. Mutiny helps you to take the plunge.","title":"Why is asynchronous important?"},{"location":"reference/why-is-asynchronous-important/#why-is-asynchronous-important","text":"We are living in a distributed world. Most of the applications built nowadays are distributed systems. The Cloud, IoT, microservices, mobile application, even simple CRUD applications are distributed applications. Still, developing distributed systems is hard! Communications in distributed systems are inherently asynchronous and unreliable. Anything can go wrong, anytime, and often with no prior notice. Network disruptions, unavailable services, software, or hardware failures are just a tiny subset of the wide variety of failures that can happen in distributed systems. Correctly building distributed applications is a considerable challenge, as it requires re-assessing almost everything we know from traditional software development. Most classic applications use a synchronous development model. Synchronous code is easy to reason about, more comfortable to write and read than asynchronous code, but it has some hidden cost. This cost emerges when building I/O intensive applications, quite common in distributed applications. In general, these traditional applications assign one thread per request, and so they handle multiple concurrent requests with multiple threads. When the request processing needs to interact over the network, it uses that worker thread, which blocks the thread until the response has been received. This response may never come, so you need to add watchdogs handling timeouts and other resilience patterns. And, to handle more requests concurrently, you need to create more threads. Threads come at a cost. Each thread requires memory, and the more threads you have, the more CPU cycles are used to handle the context switches. Thus, this model ends up being costly, limits the deployment density, and on the Cloud means that you pay bigger bills. Fortunately, there is another way, and it relies on non-blocking I/O, an efficient way to handle I/O interactions that do not require additional threads. While applications using non-blocking I/O are more efficient and better suited for the Cloud\u2019s distributed nature, they come with a considerable constraint: you must never block the I/O thread. Thus, you need to implement your business logic using an asynchronous development model. I/O is not the only reason why asynchronous is essential in Today\u2019s systems. Most of the interactions in the real world are asynchronous and event-driven. Representing these interactions using synchronous processes is not only wrong; it also introduces fragility in your application. Asynchronous is a significant shift. Mutiny helps you to take the plunge.","title":"Why is asynchronous important?"},{"location":"tutorials/creating-multi-pipelines/","tags":["tutorial","beginner"],"text":"Creating Multi pipelines # A Multi represents a stream of data. A stream can emit 0, 1, n, or an infinite number of items. You will rarely create instances of Multi yourself but instead use a reactive client that exposes a Mutiny API. Still, just like Uni there exists a rich API for creating Multi objects. The Multi type # A Multi<T> is a data stream that: emits 0..n item events emits a failure event emits a completion event for bounded streams Warning Failures are terminal events: after having received a failure no further item will be emitted. Multi<T> provides many operators that create, transform, and orchestrate Multi sequences. The operators can be used to define a processing pipeline. The events flow in this pipeline, and each operator can process or transform the events. Multis are lazy by nature. To trigger the computation, you must subscribe. The following snippet provides a simple example of pipeline using Multi : 1 2 3 4 5 Multi . createFrom (). items ( 1 , 2 , 3 , 4 , 5 ) . onItem (). transform ( i -> i * 2 ) . select (). first ( 3 ) . onFailure (). recoverWithItem ( 0 ) . subscribe (). with ( System . out :: println ); Subscribing to a Multi # Remember, if you don\u2019t subscribe, nothing is going to happen. Also, the pipeline is materialized for each subscription . When subscribing to a Multi, you can pass an item callback (invoked when the item is emitted), or pass two callbacks, one receiving the item and one receiving the failure, or three callbacks to handle respectively the item, failure and completion events. 1 2 3 4 5 Cancellable cancellable = multi . subscribe (). with ( item -> System . out . println ( item ), failure -> System . out . println ( \"Failed with \" + failure ), () -> System . out . println ( \"Completed\" )); Note the returned Cancellable : this object allows canceling the stream if need be. Creating Multi from items # There are many ways to create Multi instances. See Multi.createFrom() to see all the possibilities. For instance, you can create a Multi from known items or from an Iterable : 1 2 Multi < Integer > multiFromItems = Multi . createFrom (). items ( 1 , 2 , 3 , 4 ); Multi < Integer > multiFromIterable = Multi . createFrom (). iterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 )); Every subscriber receives the same set of items ( 1 , 2 \u2026 5 ) just after the subscription. You can also use Suppliers : 1 2 3 AtomicInteger counter = new AtomicInteger (); Multi < Integer > multi = Multi . createFrom (). items (() -> IntStream . range ( counter . getAndIncrement (), counter . get () * 2 ). boxed ()); The Supplier is called for every subscriber, so each of them will get different values. Tip You can create ranges using Multi.createFrom().range(start, end) . Creating failing Multis # Streams can also fail. Failures are used to indicate to the downstream subscribers that the source encountered a terrible error and cannot continue emitting items. Create failed Multi instances with: 1 2 3 4 5 // Pass an exception directly: Multi < Integer > failed1 = Multi . createFrom (). failure ( new Exception ( \"boom\" )); // Pass a supplier called for every subscriber: Multi < Integer > failed2 = Multi . createFrom (). failure (() -> new Exception ( \"boom\" )); Creating empty Multis # Unlike Uni, Multi streams don\u2019t send null items (this is forbidden in reactive streams ). Instead Multi streams send completion events indicating that there are no more items to consume. Of course, the completion event can happen even if there are no items, creating an empty stream. You can create such a stream using: 1 Multi < String > multi = Multi . createFrom (). empty (); Creating Multis using an emitter ( advanced ) # You can create a Multi using an emitter. This approach is useful when integrating callback-based APIs: 1 2 3 4 5 6 Multi < Integer > multi = Multi . createFrom (). emitter ( em -> { em . emit ( 1 ); em . emit ( 2 ); em . emit ( 3 ); em . complete (); }); The emitter can also send a failure. It can also get notified of cancellation to, for example, stop the work in progress. Creating Multis from ticks ( advanced ) # You can create a stream that emit a ticks periodically: 1 Multi < Long > ticks = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 100 )); The downstream receives a long, which is a counter. For the first tick, it\u2019s 0, then 1, then 2, and so on. Creating Multis from a generator ( advanced ) # You can create a stream from some initial state , and a generator function : 1 2 3 4 5 6 7 8 9 10 Multi < Object > sequence = Multi . createFrom (). generator (() -> 1 , ( n , emitter ) -> { int next = n + ( n / 2 ) + 1 ; if ( n < 50 ) { emitter . emit ( next ); } else { emitter . complete (); } return next ; }); The initial state is given through a supplier (here () -> 1 ). The generator function accepts 2 arguments: the current state, an emitter that can emit a new item, emit a failure, or emit a completion. The generator function return value is the next current state . Running the previous example gives the following number suite: {2, 4, 7, 11, 17, 26, 40, 61} .","title":"Creating `Multi` pipelines"},{"location":"tutorials/creating-multi-pipelines/#creating-multi-pipelines","text":"A Multi represents a stream of data. A stream can emit 0, 1, n, or an infinite number of items. You will rarely create instances of Multi yourself but instead use a reactive client that exposes a Mutiny API. Still, just like Uni there exists a rich API for creating Multi objects.","title":"Creating Multi pipelines"},{"location":"tutorials/creating-multi-pipelines/#the-multi-type","text":"A Multi<T> is a data stream that: emits 0..n item events emits a failure event emits a completion event for bounded streams Warning Failures are terminal events: after having received a failure no further item will be emitted. Multi<T> provides many operators that create, transform, and orchestrate Multi sequences. The operators can be used to define a processing pipeline. The events flow in this pipeline, and each operator can process or transform the events. Multis are lazy by nature. To trigger the computation, you must subscribe. The following snippet provides a simple example of pipeline using Multi : 1 2 3 4 5 Multi . createFrom (). items ( 1 , 2 , 3 , 4 , 5 ) . onItem (). transform ( i -> i * 2 ) . select (). first ( 3 ) . onFailure (). recoverWithItem ( 0 ) . subscribe (). with ( System . out :: println );","title":"The Multi type"},{"location":"tutorials/creating-multi-pipelines/#subscribing-to-a-multi","text":"Remember, if you don\u2019t subscribe, nothing is going to happen. Also, the pipeline is materialized for each subscription . When subscribing to a Multi, you can pass an item callback (invoked when the item is emitted), or pass two callbacks, one receiving the item and one receiving the failure, or three callbacks to handle respectively the item, failure and completion events. 1 2 3 4 5 Cancellable cancellable = multi . subscribe (). with ( item -> System . out . println ( item ), failure -> System . out . println ( \"Failed with \" + failure ), () -> System . out . println ( \"Completed\" )); Note the returned Cancellable : this object allows canceling the stream if need be.","title":"Subscribing to a Multi"},{"location":"tutorials/creating-multi-pipelines/#creating-multi-from-items","text":"There are many ways to create Multi instances. See Multi.createFrom() to see all the possibilities. For instance, you can create a Multi from known items or from an Iterable : 1 2 Multi < Integer > multiFromItems = Multi . createFrom (). items ( 1 , 2 , 3 , 4 ); Multi < Integer > multiFromIterable = Multi . createFrom (). iterable ( Arrays . asList ( 1 , 2 , 3 , 4 , 5 )); Every subscriber receives the same set of items ( 1 , 2 \u2026 5 ) just after the subscription. You can also use Suppliers : 1 2 3 AtomicInteger counter = new AtomicInteger (); Multi < Integer > multi = Multi . createFrom (). items (() -> IntStream . range ( counter . getAndIncrement (), counter . get () * 2 ). boxed ()); The Supplier is called for every subscriber, so each of them will get different values. Tip You can create ranges using Multi.createFrom().range(start, end) .","title":"Creating Multi from items"},{"location":"tutorials/creating-multi-pipelines/#creating-failing-multis","text":"Streams can also fail. Failures are used to indicate to the downstream subscribers that the source encountered a terrible error and cannot continue emitting items. Create failed Multi instances with: 1 2 3 4 5 // Pass an exception directly: Multi < Integer > failed1 = Multi . createFrom (). failure ( new Exception ( \"boom\" )); // Pass a supplier called for every subscriber: Multi < Integer > failed2 = Multi . createFrom (). failure (() -> new Exception ( \"boom\" ));","title":"Creating failing Multis"},{"location":"tutorials/creating-multi-pipelines/#creating-empty-multis","text":"Unlike Uni, Multi streams don\u2019t send null items (this is forbidden in reactive streams ). Instead Multi streams send completion events indicating that there are no more items to consume. Of course, the completion event can happen even if there are no items, creating an empty stream. You can create such a stream using: 1 Multi < String > multi = Multi . createFrom (). empty ();","title":"Creating empty Multis"},{"location":"tutorials/creating-multi-pipelines/#creating-multis-using-an-emitter-advanced","text":"You can create a Multi using an emitter. This approach is useful when integrating callback-based APIs: 1 2 3 4 5 6 Multi < Integer > multi = Multi . createFrom (). emitter ( em -> { em . emit ( 1 ); em . emit ( 2 ); em . emit ( 3 ); em . complete (); }); The emitter can also send a failure. It can also get notified of cancellation to, for example, stop the work in progress.","title":"Creating Multis using an emitter (advanced)"},{"location":"tutorials/creating-multi-pipelines/#creating-multis-from-ticks-advanced","text":"You can create a stream that emit a ticks periodically: 1 Multi < Long > ticks = Multi . createFrom (). ticks (). every ( Duration . ofMillis ( 100 )); The downstream receives a long, which is a counter. For the first tick, it\u2019s 0, then 1, then 2, and so on.","title":"Creating Multis from ticks (advanced)"},{"location":"tutorials/creating-multi-pipelines/#creating-multis-from-a-generator-advanced","text":"You can create a stream from some initial state , and a generator function : 1 2 3 4 5 6 7 8 9 10 Multi < Object > sequence = Multi . createFrom (). generator (() -> 1 , ( n , emitter ) -> { int next = n + ( n / 2 ) + 1 ; if ( n < 50 ) { emitter . emit ( next ); } else { emitter . complete (); } return next ; }); The initial state is given through a supplier (here () -> 1 ). The generator function accepts 2 arguments: the current state, an emitter that can emit a new item, emit a failure, or emit a completion. The generator function return value is the next current state . Running the previous example gives the following number suite: {2, 4, 7, 11, 17, 26, 40, 61} .","title":"Creating Multis from a generator (advanced)"},{"location":"tutorials/creating-uni-pipelines/","tags":["tutorial","beginner"],"text":"Creating Uni pipelines # A Uni represents a stream that can only emit either an item or a failure event. You rarely create instances of Uni yourself, but, instead, use a reactive client exposing a Mutiny API that provides Uni objects. That being said, it can be handy at times. The Uni type # A Uni<T> is a specialized stream that emits only an item or a failure. Typically, Uni<T> are great to represent asynchronous actions such as a remote procedure call, an HTTP request, or an operation producing a single result. Uni<T> provides many operators that create, transform, and orchestrate Uni sequences. As said, Uni<T> emits either an item or a failure. Note that the item can be null, and the Uni API has specific methods for this case. Typically, a Uni<Void> always emits null as item event or a failure if the represented operation fails. You can consider the item event as a completion signal indicating the success of the operation. The offered operators can be used to define a processing pipeline. The event, either the item or failure, flows in this pipeline, and each operator can process or transform the event. Unis are lazy by nature. To trigger the computation, you must have a final subscriber indicating your interest. The following snippet provides a simple example of pipeline using Uni : 1 2 3 4 Uni . createFrom (). item ( 1 ) . onItem (). transform ( i -> \"hello-\" + i ) . onItem (). delayIt (). by ( Duration . ofMillis ( 100 )) . subscribe (). with ( System . out :: println ); Subscribing to a Uni # Important Remember: if you don\u2019t subscribe, nothing is going to happen. What\u2019s more, the pipeline is materialized for each subscription . When subscribing to a Uni , you can pass an item callback (invoked when the item is emitted), or two callbacks (one receiving the item and one receiving the failure): 1 2 3 4 Cancellable cancellable = uni . subscribe (). with ( item -> System . out . println ( item ), failure -> System . out . println ( \"Failed with \" + failure )); Note the returned Cancellable : this object allows canceling the operation if need be. Creating Unis from items # There are many ways to create Uni instances. Use Uni.createFrom() to see all the possibilities. You can, for instance, create a Uni from a known value: 1 Uni < Integer > uni = Uni . createFrom (). item ( 1 ); Every subscriber receives the item 1 just after the subscription. You can also pass a Supplier : 1 2 AtomicInteger counter = new AtomicInteger (); Uni < Integer > uni = Uni . createFrom (). item (() -> counter . getAndIncrement ()); The Supplier is called for every subscriber. So, each of them will get a different value. Creating failing Unis # Operations represented by Unis can also emit a failure event, indicating that the operation failed. You can create failed Uni instances with: 1 2 3 4 5 // Pass an exception directly: Uni < Integer > failed1 = Uni . createFrom (). failure ( new Exception ( \"boom\" )); // Pass a supplier called for every subscriber: Uni < Integer > failed2 = Uni . createFrom (). failure (() -> new Exception ( \"boom\" )); Creating Uni<Void> # When the represented operation to not produce a result, you still need a way to indicate the operation\u2019s completion. For this, you need to emit a null item: 1 Uni < Void > uni = Uni . createFrom (). nullItem (); Creating Unis using an emitter ( advanced ) # You can create a Uni using an emitter. This approach is useful when integrating callback-based APIs: 1 2 3 4 Uni < String > uni = Uni . createFrom (). emitter ( em -> { // When the result is available, emit it em . complete ( result ); }); The emitter can also send a failure. It can also get notified of cancellation to, for example, stop the work in progress. Creating Unis from a CompletionStage ( advanced ) # You can also Uni objects from CompletionStage / CompletableFuture . This is useful when integrating with APIs that are based on these types: 1 Uni < String > uni = Uni . createFrom (). completionStage ( stage ); Tip You can also create a CompletionStage from a Uni using uni.subscribe().asCompletionStage()","title":"Creating `Uni` pipelines"},{"location":"tutorials/creating-uni-pipelines/#creating-uni-pipelines","text":"A Uni represents a stream that can only emit either an item or a failure event. You rarely create instances of Uni yourself, but, instead, use a reactive client exposing a Mutiny API that provides Uni objects. That being said, it can be handy at times.","title":"Creating Uni pipelines"},{"location":"tutorials/creating-uni-pipelines/#the-uni-type","text":"A Uni<T> is a specialized stream that emits only an item or a failure. Typically, Uni<T> are great to represent asynchronous actions such as a remote procedure call, an HTTP request, or an operation producing a single result. Uni<T> provides many operators that create, transform, and orchestrate Uni sequences. As said, Uni<T> emits either an item or a failure. Note that the item can be null, and the Uni API has specific methods for this case. Typically, a Uni<Void> always emits null as item event or a failure if the represented operation fails. You can consider the item event as a completion signal indicating the success of the operation. The offered operators can be used to define a processing pipeline. The event, either the item or failure, flows in this pipeline, and each operator can process or transform the event. Unis are lazy by nature. To trigger the computation, you must have a final subscriber indicating your interest. The following snippet provides a simple example of pipeline using Uni : 1 2 3 4 Uni . createFrom (). item ( 1 ) . onItem (). transform ( i -> \"hello-\" + i ) . onItem (). delayIt (). by ( Duration . ofMillis ( 100 )) . subscribe (). with ( System . out :: println );","title":"The Uni type"},{"location":"tutorials/creating-uni-pipelines/#subscribing-to-a-uni","text":"Important Remember: if you don\u2019t subscribe, nothing is going to happen. What\u2019s more, the pipeline is materialized for each subscription . When subscribing to a Uni , you can pass an item callback (invoked when the item is emitted), or two callbacks (one receiving the item and one receiving the failure): 1 2 3 4 Cancellable cancellable = uni . subscribe (). with ( item -> System . out . println ( item ), failure -> System . out . println ( \"Failed with \" + failure )); Note the returned Cancellable : this object allows canceling the operation if need be.","title":"Subscribing to a Uni"},{"location":"tutorials/creating-uni-pipelines/#creating-unis-from-items","text":"There are many ways to create Uni instances. Use Uni.createFrom() to see all the possibilities. You can, for instance, create a Uni from a known value: 1 Uni < Integer > uni = Uni . createFrom (). item ( 1 ); Every subscriber receives the item 1 just after the subscription. You can also pass a Supplier : 1 2 AtomicInteger counter = new AtomicInteger (); Uni < Integer > uni = Uni . createFrom (). item (() -> counter . getAndIncrement ()); The Supplier is called for every subscriber. So, each of them will get a different value.","title":"Creating Unis from items"},{"location":"tutorials/creating-uni-pipelines/#creating-failing-unis","text":"Operations represented by Unis can also emit a failure event, indicating that the operation failed. You can create failed Uni instances with: 1 2 3 4 5 // Pass an exception directly: Uni < Integer > failed1 = Uni . createFrom (). failure ( new Exception ( \"boom\" )); // Pass a supplier called for every subscriber: Uni < Integer > failed2 = Uni . createFrom (). failure (() -> new Exception ( \"boom\" ));","title":"Creating failing Unis"},{"location":"tutorials/creating-uni-pipelines/#creating-univoid","text":"When the represented operation to not produce a result, you still need a way to indicate the operation\u2019s completion. For this, you need to emit a null item: 1 Uni < Void > uni = Uni . createFrom (). nullItem ();","title":"Creating Uni&lt;Void&gt;"},{"location":"tutorials/creating-uni-pipelines/#creating-unis-using-an-emitter-advanced","text":"You can create a Uni using an emitter. This approach is useful when integrating callback-based APIs: 1 2 3 4 Uni < String > uni = Uni . createFrom (). emitter ( em -> { // When the result is available, emit it em . complete ( result ); }); The emitter can also send a failure. It can also get notified of cancellation to, for example, stop the work in progress.","title":"Creating Unis using an emitter (advanced)"},{"location":"tutorials/creating-uni-pipelines/#creating-unis-from-a-completionstage-advanced","text":"You can also Uni objects from CompletionStage / CompletableFuture . This is useful when integrating with APIs that are based on these types: 1 Uni < String > uni = Uni . createFrom (). completionStage ( stage ); Tip You can also create a CompletionStage from a Uni using uni.subscribe().asCompletionStage()","title":"Creating Unis from a CompletionStage (advanced)"},{"location":"tutorials/getting-mutiny/","tags":["tutorial","beginner"],"text":"Getting started with Mutiny # Using Mutiny in a Java application # Add the dependency to your project using your preferred build tool: Apache Maven Gradle (Groovy) Gradle (Kotlin) JBang <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny </artifactId> <version> 2.1.0 </version> </dependency> implementation 'io.smallrye.reactive:mutiny:2.1.0' implementation ( \"io.smallrye.reactive:mutiny:2.1.0\" ) //DEPS io.smallrye.reactive:mutiny:2.1.0 Using Mutiny with Quarkus # Most of the Quarkus extensions with reactive capabilities already depend on Mutiny. You can also add the quarkus-mutiny dependency explicitly from the command-line: mvn quarkus:add-extension -Dextensions = mutiny or by editing the pom.xml file and adding: <dependency> <groupId> io.quarkus </groupId> <artifactId> quarkus-mutiny </artifactId> </dependency> Using Mutiny with Vert.x # Most of the Eclipse Vert.x stack modules are available through the SmallRye Mutiny Vert.x Bindings project. Bindings for Vert.x modules are named by prepending smallrye-mutiny- . As an example here\u2019s how to add a dependency to the vertx-core Mutiny bindings: Apache Maven Gradle (Groovy) Gradle (Kotlin) JBang <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-mutiny-vertx-core </artifactId> <version> 3.2.0 </version> </dependency> implementation 'io.smallrye.reactive:smallrye-mutiny-vertx-core:3.2.0' implementation ( \"io.smallrye.reactive:smallrye-mutiny-vertx-core:3.2.0\" ) //DEPS io.smallrye.reactive:smallrye-mutiny-vertx-core:3.2.0","title":"Getting started with Mutiny"},{"location":"tutorials/getting-mutiny/#getting-started-with-mutiny","text":"","title":"Getting started with Mutiny"},{"location":"tutorials/getting-mutiny/#using-mutiny-in-a-java-application","text":"Add the dependency to your project using your preferred build tool: Apache Maven Gradle (Groovy) Gradle (Kotlin) JBang <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> mutiny </artifactId> <version> 2.1.0 </version> </dependency> implementation 'io.smallrye.reactive:mutiny:2.1.0' implementation ( \"io.smallrye.reactive:mutiny:2.1.0\" ) //DEPS io.smallrye.reactive:mutiny:2.1.0","title":"Using Mutiny in a Java application"},{"location":"tutorials/getting-mutiny/#using-mutiny-with-quarkus","text":"Most of the Quarkus extensions with reactive capabilities already depend on Mutiny. You can also add the quarkus-mutiny dependency explicitly from the command-line: mvn quarkus:add-extension -Dextensions = mutiny or by editing the pom.xml file and adding: <dependency> <groupId> io.quarkus </groupId> <artifactId> quarkus-mutiny </artifactId> </dependency>","title":"Using Mutiny with Quarkus"},{"location":"tutorials/getting-mutiny/#using-mutiny-with-vertx","text":"Most of the Eclipse Vert.x stack modules are available through the SmallRye Mutiny Vert.x Bindings project. Bindings for Vert.x modules are named by prepending smallrye-mutiny- . As an example here\u2019s how to add a dependency to the vertx-core Mutiny bindings: Apache Maven Gradle (Groovy) Gradle (Kotlin) JBang <dependency> <groupId> io.smallrye.reactive </groupId> <artifactId> smallrye-mutiny-vertx-core </artifactId> <version> 3.2.0 </version> </dependency> implementation 'io.smallrye.reactive:smallrye-mutiny-vertx-core:3.2.0' implementation ( \"io.smallrye.reactive:smallrye-mutiny-vertx-core:3.2.0\" ) //DEPS io.smallrye.reactive:smallrye-mutiny-vertx-core:3.2.0","title":"Using Mutiny with Vert.x"},{"location":"tutorials/handling-failures/","tags":["tutorial","beginner"],"text":"Handling failures # Mutiny provides several operators to handle failures. Remember, failures are terminal events sent by the observed stream, indicating that something bad happened. After a failure, no more items are being received. When such an event is received, you can: propagate the failure downstream (default), or transform the failure into another failure, or recover from it by switching to another stream, passing a fallback item, or completing, or retrying (covered in the next guide) If you don\u2019t handle the failure event, it is propagated downstream until a stage handles the failure or reaches the final subscriber. Important on Multi , a failure cancels the subscription, meaning you will not receive any more items. The retry operator lets you re-subscribe and continue the reception. Observing failures # It can be useful to execute some custom action when a failure happens. For example, you can log the failure: 1 2 3 4 5 Uni < String > u = uni . onFailure (). invoke ( failure -> log ( failure )); Multi < String > m = multi . onFailure (). invoke ( failure -> log ( failure )); Tip You can also execute an asynchronous action using onFailure().call(Function<Throwable, Uni<?>) . The received failure will be propagated downstream when the Uni produced by the passed function emits its item. Transforming failures # Another useful action on failure is to transform the failure into a more meaningful failure. Typically, you can wrap a low-level failure (like an IOException ) into a business failure ( ServiceUnavailableException ): 1 2 3 Uni < String > u = uni . onFailure (). transform ( failure -> new ServiceUnavailableException ( failure )); Recovering using fallback item(s) # In general, upon failure, you want to recover. The first approach is to recover by replacing the failure with an item: 1 2 3 4 5 Uni < String > u1 = uni . onFailure (). recoverWithItem ( \"hello\" ); Uni < String > u2 = uni . onFailure (). recoverWithItem ( f -> getFallback ( f )); The second approach receives a Supplier to compute the fallback item. For the downstream, it didn\u2019t fail; it gets the fallback item instead. However, don\u2019t forget that failures are terminal! So for Multi , the downstream receives the fallback item followed by the completion signal, as no more items can be produced. Completing on failure # When observing a Multi you can replace the failure with the completion signal: 1 2 Multi < String > m = multi . onFailure (). recoverWithCompletion (); The downstream won\u2019t see the failure, just the completion event. Switching to another stream # On failure, you may want to switch to an alternate stream. When the failure is received, it subscribes to this other stream and propagates the items from this stream instead: 1 2 3 4 5 Uni < String > u = uni . onFailure (). recoverWithUni ( f -> getFallbackUni ( f )); Multi < String > m = multi . onFailure (). recoverWithMulti ( f -> getFallbackMulti ( f )); The recoverWithUni and recoverWithMulti methods replace the failed upstream with the returned stream. The fallback streams must produce the same type of event as the original upstream.","title":"Handling failures"},{"location":"tutorials/handling-failures/#handling-failures","text":"Mutiny provides several operators to handle failures. Remember, failures are terminal events sent by the observed stream, indicating that something bad happened. After a failure, no more items are being received. When such an event is received, you can: propagate the failure downstream (default), or transform the failure into another failure, or recover from it by switching to another stream, passing a fallback item, or completing, or retrying (covered in the next guide) If you don\u2019t handle the failure event, it is propagated downstream until a stage handles the failure or reaches the final subscriber. Important on Multi , a failure cancels the subscription, meaning you will not receive any more items. The retry operator lets you re-subscribe and continue the reception.","title":"Handling failures"},{"location":"tutorials/handling-failures/#observing-failures","text":"It can be useful to execute some custom action when a failure happens. For example, you can log the failure: 1 2 3 4 5 Uni < String > u = uni . onFailure (). invoke ( failure -> log ( failure )); Multi < String > m = multi . onFailure (). invoke ( failure -> log ( failure )); Tip You can also execute an asynchronous action using onFailure().call(Function<Throwable, Uni<?>) . The received failure will be propagated downstream when the Uni produced by the passed function emits its item.","title":"Observing failures"},{"location":"tutorials/handling-failures/#transforming-failures","text":"Another useful action on failure is to transform the failure into a more meaningful failure. Typically, you can wrap a low-level failure (like an IOException ) into a business failure ( ServiceUnavailableException ): 1 2 3 Uni < String > u = uni . onFailure (). transform ( failure -> new ServiceUnavailableException ( failure ));","title":"Transforming failures"},{"location":"tutorials/handling-failures/#recovering-using-fallback-items","text":"In general, upon failure, you want to recover. The first approach is to recover by replacing the failure with an item: 1 2 3 4 5 Uni < String > u1 = uni . onFailure (). recoverWithItem ( \"hello\" ); Uni < String > u2 = uni . onFailure (). recoverWithItem ( f -> getFallback ( f )); The second approach receives a Supplier to compute the fallback item. For the downstream, it didn\u2019t fail; it gets the fallback item instead. However, don\u2019t forget that failures are terminal! So for Multi , the downstream receives the fallback item followed by the completion signal, as no more items can be produced.","title":"Recovering using fallback item(s)"},{"location":"tutorials/handling-failures/#completing-on-failure","text":"When observing a Multi you can replace the failure with the completion signal: 1 2 Multi < String > m = multi . onFailure (). recoverWithCompletion (); The downstream won\u2019t see the failure, just the completion event.","title":"Completing on failure"},{"location":"tutorials/handling-failures/#switching-to-another-stream","text":"On failure, you may want to switch to an alternate stream. When the failure is received, it subscribes to this other stream and propagates the items from this stream instead: 1 2 3 4 5 Uni < String > u = uni . onFailure (). recoverWithUni ( f -> getFallbackUni ( f )); Multi < String > m = multi . onFailure (). recoverWithMulti ( f -> getFallbackMulti ( f )); The recoverWithUni and recoverWithMulti methods replace the failed upstream with the returned stream. The fallback streams must produce the same type of event as the original upstream.","title":"Switching to another stream"},{"location":"tutorials/hello-mutiny/","tags":["tutorial","beginner"],"text":"Hello Mutiny! # Once you made Mutiny available to your classpath, you can start writing code. Let\u2019s start with this simple program: 1 2 3 4 5 6 7 8 9 10 11 import io.smallrye.mutiny.Uni ; public class FirstProgram { public static void main ( String [] args ) { Uni . createFrom (). item ( \"hello\" ) . onItem (). transform ( item -> item + \" mutiny\" ) . onItem (). transform ( String :: toUpperCase ) . subscribe (). with ( item -> System . out . println ( \">> \" + item )); } } This program prints: >> HELLO MUTINY Dissecting the pipeline # What\u2019s interesting is how this message is built . We described a processing pipeline taking an item, processing it and finally consuming it. First, we create a Uni , one of the two types with Multi that Mutiny provides. A Uni is a stream emitting either a single item or a failure. Here, we create a Uni emitting the \"hello\" item. This is the input of our pipeline. Then we process this item: we append \" mutiny\" , then we make it an uppercase string. This forms the processing part of our pipeline, and then we finally subscribe to the pipeline. This last part is essential. If you don\u2019t have a final subscriber, nothing is going to happen. Mutiny types are lazy, meaning that you need to express your interest. If you don\u2019t the computation won\u2019t even start. Important If your program doesn\u2019t do anything, verify that you didn\u2019t forget to subscribe! Mutiny uses a builder API! # Another important aspect is the pipeline construction. Appending a new stage to a pipeline returns a new Uni. The previous program is equivalent to: 1 2 3 4 5 Uni < String > uni1 = Uni . createFrom (). item ( \"hello\" ); Uni < String > uni2 = uni1 . onItem (). transform ( item -> item + \" mutiny\" ); Uni < String > uni3 = uni2 . onItem (). transform ( String :: toUpperCase ); uni3 . subscribe (). with ( item -> System . out . println ( \">> \" + item )); It is fundamental to understand that this program is not equivalent to: 1 2 3 4 5 6 Uni < String > uni = Uni . createFrom (). item ( \"hello\" ); uni . onItem (). transform ( item -> item + \" mutiny\" ); uni . onItem (). transform ( String :: toUpperCase ); uni . subscribe (). with ( item -> System . out . println ( \">> \" + item )); This program just prints \">> hello\" , as it does not use the appended stages and the final subscriber consumes the first Uni. Warning Mutiny APIs are not fluent and each computation stage returns a new object.","title":"Hello Mutiny!"},{"location":"tutorials/hello-mutiny/#hello-mutiny","text":"Once you made Mutiny available to your classpath, you can start writing code. Let\u2019s start with this simple program: 1 2 3 4 5 6 7 8 9 10 11 import io.smallrye.mutiny.Uni ; public class FirstProgram { public static void main ( String [] args ) { Uni . createFrom (). item ( \"hello\" ) . onItem (). transform ( item -> item + \" mutiny\" ) . onItem (). transform ( String :: toUpperCase ) . subscribe (). with ( item -> System . out . println ( \">> \" + item )); } } This program prints: >> HELLO MUTINY","title":"Hello Mutiny!"},{"location":"tutorials/hello-mutiny/#dissecting-the-pipeline","text":"What\u2019s interesting is how this message is built . We described a processing pipeline taking an item, processing it and finally consuming it. First, we create a Uni , one of the two types with Multi that Mutiny provides. A Uni is a stream emitting either a single item or a failure. Here, we create a Uni emitting the \"hello\" item. This is the input of our pipeline. Then we process this item: we append \" mutiny\" , then we make it an uppercase string. This forms the processing part of our pipeline, and then we finally subscribe to the pipeline. This last part is essential. If you don\u2019t have a final subscriber, nothing is going to happen. Mutiny types are lazy, meaning that you need to express your interest. If you don\u2019t the computation won\u2019t even start. Important If your program doesn\u2019t do anything, verify that you didn\u2019t forget to subscribe!","title":"Dissecting the pipeline"},{"location":"tutorials/hello-mutiny/#mutiny-uses-a-builder-api","text":"Another important aspect is the pipeline construction. Appending a new stage to a pipeline returns a new Uni. The previous program is equivalent to: 1 2 3 4 5 Uni < String > uni1 = Uni . createFrom (). item ( \"hello\" ); Uni < String > uni2 = uni1 . onItem (). transform ( item -> item + \" mutiny\" ); Uni < String > uni3 = uni2 . onItem (). transform ( String :: toUpperCase ); uni3 . subscribe (). with ( item -> System . out . println ( \">> \" + item )); It is fundamental to understand that this program is not equivalent to: 1 2 3 4 5 6 Uni < String > uni = Uni . createFrom (). item ( \"hello\" ); uni . onItem (). transform ( item -> item + \" mutiny\" ); uni . onItem (). transform ( String :: toUpperCase ); uni . subscribe (). with ( item -> System . out . println ( \">> \" + item )); This program just prints \">> hello\" , as it does not use the appended stages and the final subscriber consumes the first Uni. Warning Mutiny APIs are not fluent and each computation stage returns a new object.","title":"Mutiny uses a builder API!"},{"location":"tutorials/observing-events/","tags":["tutorial","beginner"],"text":"Observing events # Learn how to observe the events emitted by Uni and Multi instances. Events # Uni and Multi emit events . Your code is going to observe and process these events. Most of the time, your code is only interested in item and failure events. But there are other kinds of events such as cancellation, request, completion, and so on: Event Uni / Multi Direction Note item Uni + Multi upstream -> downstream The upstream sent an item. failure Uni + Multi upstream -> downstream The upstream failed. completion Multi upstream -> downstream The upstream completed. subscribe Uni and Multi downstream -> upstream A downstream subscriber is interested in the data. subscription Uni and Multi upstream -> downstream Event happening after a subscribe event to indicate that the upstream acknowledged the subscription. cancellation Uni and Multi downstream -> upstream A downstream subscriber does not want any more events. overflow Multi upstream -> downstream The upstream has emitted more than the downstream can handle. request Multi downstream -> upstream The downstream indicates its capacity to handle n items. It\u2019s not rare that you need to look at these various events to understand better what\u2019s going on or implement specific side effects. For example, you may need to close a resource after a completion event or log a message on failure or cancellation. For each kind of event, there is an associated group providing the methods to handle that specific event: onItem() , onFailure() , onCompletion() and so on. These groups provide two methods to peek at the various events without impacting its distribution: invoke(...) and call(...) . It does not transform the received event; it notifies you that something happened and let you react. Once this reaction completes, the event is propagated downstream or upstream depending on the direction of the event. The invoke method # The invoke method is synchronous and the passed callback does not return anything. Mutiny invokes the configured callback when the observed stream dispatches the event: 1 2 3 4 5 Uni < String > u = uni . onItem () . invoke ( i -> System . out . println ( \"Received item: \" + i )); Multi < String > m = multi . onItem () . invoke ( i -> System . out . println ( \"Received item: \" + i )); As said above, invoke is synchronous. Mutiny invokes the callback and propagates the event downstream when the callback returns. It blocks the dispatching. sequenceDiagram autonumber participant M as Multi participant O as onItem().invoke(...) participant D as Downstream M->>O: item1 O->>D: item1 M->>O: item2 O->>D: item2 M->>O: item3 Note over O: callback execution O->>D: item3 Of course, we highly recommend you not to block. The following snippets show how you can log the different types of events. 1 2 3 4 5 6 7 8 9 10 11 12 13 multi . onSubscription () . invoke (() -> System . out . println ( \"\u2b07\ufe0f Subscribed\" )) . onItem () . invoke ( i -> System . out . println ( \"\u2b07\ufe0f Received item: \" + i )) . onFailure () . invoke ( f -> System . out . println ( \"\u2b07\ufe0f Failed with \" + f )) . onCompletion () . invoke (() -> System . out . println ( \"\u2b07\ufe0f Completed\" )) . onCancellation () . invoke (() -> System . out . println ( \"\u2b06\ufe0f Cancelled\" )) . onRequest () . invoke ( l -> System . out . println ( \"\u2b06\ufe0f Requested: \" + l )); The arrows from the previous code snippet indicate if the event comes from the upstream (source) or downstream (consumer) (see the table above for more details). The invoke method does not change the event, except in one case. If the callback throws an exception, the downstream does not get the actual event but get a failure event instead. When observing the failure event, if the callback throws an exception, Mutiny propagates a CompositeException aggregating the original failure and the callback failure. The call method # Unlike invoke , call is asynchronous, and the callback returns a Uni<?> object. call is often used when you need to implement asynchronous side-effects, such as closing resources. sequenceDiagram autonumber participant M as Multi participant O as onItem().call(...) participant U as Returned Unis participant D as Downstream M->>O: item1 O--)U: item1 U--)O: result1 O->>D: result1 M->>O: item2 O--)U: item2 U--)O: result2 O->>D: result2 M->>O: item3 O--)U: item3 U--)O: result3 O->>D: result3 Mutiny does not dispatch the original event downstream until the Uni returned by the callback emits an item: 1 2 3 4 5 6 multi . onItem (). call ( i -> Uni . createFrom (). voidItem () . onItem (). delayIt (). by ( Duration . ofSeconds ( 1 ) ) ); As shown in the previous snippet, you can use this approach to delay items. But, the primary use case is about completing asynchronous actions such as calling an asynchronous close method on a resource: 1 2 multi . onCompletion (). call (() -> resource . close ()); Under the hood, Mutiny gets the Uni (by invoking the callback) and subscribes to it. It observes the item or failure event from that Uni. It discards the item value as only the emission matters in this case. If the callback throws an exception or the produced Uni produces a failure, Mutiny propagates that failure (or a CompositeException ) downstream, replacing the original event. Summary # The invoke and call methods are handy when you need to observe a Uni or a Multi without changing the transiting events. Use invoke for implementing synchronous side-effects or logging events. The asynchronous nature of call makes it perfect for implementing asynchronous side-effects, such as closing resources, flushing data, delay items, and so on. The following table highlights the key differences: invoke call Nature synchronous asynchronous Return type void Uni<T> Main use cases logging, synchronous side-effects I/O operations, closing resources, flushing data","title":"Observing events"},{"location":"tutorials/observing-events/#observing-events","text":"Learn how to observe the events emitted by Uni and Multi instances.","title":"Observing events"},{"location":"tutorials/observing-events/#events","text":"Uni and Multi emit events . Your code is going to observe and process these events. Most of the time, your code is only interested in item and failure events. But there are other kinds of events such as cancellation, request, completion, and so on: Event Uni / Multi Direction Note item Uni + Multi upstream -> downstream The upstream sent an item. failure Uni + Multi upstream -> downstream The upstream failed. completion Multi upstream -> downstream The upstream completed. subscribe Uni and Multi downstream -> upstream A downstream subscriber is interested in the data. subscription Uni and Multi upstream -> downstream Event happening after a subscribe event to indicate that the upstream acknowledged the subscription. cancellation Uni and Multi downstream -> upstream A downstream subscriber does not want any more events. overflow Multi upstream -> downstream The upstream has emitted more than the downstream can handle. request Multi downstream -> upstream The downstream indicates its capacity to handle n items. It\u2019s not rare that you need to look at these various events to understand better what\u2019s going on or implement specific side effects. For example, you may need to close a resource after a completion event or log a message on failure or cancellation. For each kind of event, there is an associated group providing the methods to handle that specific event: onItem() , onFailure() , onCompletion() and so on. These groups provide two methods to peek at the various events without impacting its distribution: invoke(...) and call(...) . It does not transform the received event; it notifies you that something happened and let you react. Once this reaction completes, the event is propagated downstream or upstream depending on the direction of the event.","title":"Events"},{"location":"tutorials/observing-events/#the-invoke-method","text":"The invoke method is synchronous and the passed callback does not return anything. Mutiny invokes the configured callback when the observed stream dispatches the event: 1 2 3 4 5 Uni < String > u = uni . onItem () . invoke ( i -> System . out . println ( \"Received item: \" + i )); Multi < String > m = multi . onItem () . invoke ( i -> System . out . println ( \"Received item: \" + i )); As said above, invoke is synchronous. Mutiny invokes the callback and propagates the event downstream when the callback returns. It blocks the dispatching. sequenceDiagram autonumber participant M as Multi participant O as onItem().invoke(...) participant D as Downstream M->>O: item1 O->>D: item1 M->>O: item2 O->>D: item2 M->>O: item3 Note over O: callback execution O->>D: item3 Of course, we highly recommend you not to block. The following snippets show how you can log the different types of events. 1 2 3 4 5 6 7 8 9 10 11 12 13 multi . onSubscription () . invoke (() -> System . out . println ( \"\u2b07\ufe0f Subscribed\" )) . onItem () . invoke ( i -> System . out . println ( \"\u2b07\ufe0f Received item: \" + i )) . onFailure () . invoke ( f -> System . out . println ( \"\u2b07\ufe0f Failed with \" + f )) . onCompletion () . invoke (() -> System . out . println ( \"\u2b07\ufe0f Completed\" )) . onCancellation () . invoke (() -> System . out . println ( \"\u2b06\ufe0f Cancelled\" )) . onRequest () . invoke ( l -> System . out . println ( \"\u2b06\ufe0f Requested: \" + l )); The arrows from the previous code snippet indicate if the event comes from the upstream (source) or downstream (consumer) (see the table above for more details). The invoke method does not change the event, except in one case. If the callback throws an exception, the downstream does not get the actual event but get a failure event instead. When observing the failure event, if the callback throws an exception, Mutiny propagates a CompositeException aggregating the original failure and the callback failure.","title":"The invoke method"},{"location":"tutorials/observing-events/#the-call-method","text":"Unlike invoke , call is asynchronous, and the callback returns a Uni<?> object. call is often used when you need to implement asynchronous side-effects, such as closing resources. sequenceDiagram autonumber participant M as Multi participant O as onItem().call(...) participant U as Returned Unis participant D as Downstream M->>O: item1 O--)U: item1 U--)O: result1 O->>D: result1 M->>O: item2 O--)U: item2 U--)O: result2 O->>D: result2 M->>O: item3 O--)U: item3 U--)O: result3 O->>D: result3 Mutiny does not dispatch the original event downstream until the Uni returned by the callback emits an item: 1 2 3 4 5 6 multi . onItem (). call ( i -> Uni . createFrom (). voidItem () . onItem (). delayIt (). by ( Duration . ofSeconds ( 1 ) ) ); As shown in the previous snippet, you can use this approach to delay items. But, the primary use case is about completing asynchronous actions such as calling an asynchronous close method on a resource: 1 2 multi . onCompletion (). call (() -> resource . close ()); Under the hood, Mutiny gets the Uni (by invoking the callback) and subscribes to it. It observes the item or failure event from that Uni. It discards the item value as only the emission matters in this case. If the callback throws an exception or the produced Uni produces a failure, Mutiny propagates that failure (or a CompositeException ) downstream, replacing the original event.","title":"The call method"},{"location":"tutorials/observing-events/#summary","text":"The invoke and call methods are handy when you need to observe a Uni or a Multi without changing the transiting events. Use invoke for implementing synchronous side-effects or logging events. The asynchronous nature of call makes it perfect for implementing asynchronous side-effects, such as closing resources, flushing data, delay items, and so on. The following table highlights the key differences: invoke call Nature synchronous asynchronous Return type void Uni<T> Main use cases logging, synchronous side-effects I/O operations, closing resources, flushing data","title":"Summary"},{"location":"tutorials/retrying/","tags":["tutorial","beginner"],"text":"Retrying on failures # It is common to want to retry if something terrible happened. You can retry upon failure. The How does retry\u2026 retries blog post provides a more detailed overview of the retry mechanism. Note If despite multiple attempts, it still fails, the failure is propagated downstream. Retry multiple times # To retry on failure, use onFailure().retry() : 1 2 3 4 Uni < String > u = uni . onFailure (). retry (). atMost ( 3 ); Multi < String > m = multi . onFailure (). retry (). atMost ( 3 ); You pass the number of retries as a parameter. Important While .onFailure().retry().indefinitely() is available, it may never terminate, so use it with caution. Introducing delays # By default, retry retries immediately. When using remote services, it is often better to delay a bit the attempts. Mutiny provides a method to configure an exponential backoff: a growing delay between retries. Configure the exponential backoff as follows: 1 2 3 4 Uni < String > u = uni . onFailure (). retry () . withBackOff ( Duration . ofMillis ( 100 ), Duration . ofSeconds ( 1 )) . atMost ( 3 ); The backoff is configured with the initial and max delay. Optionally, you can also configure a jitter to add a pinch of randomness to the delay. When using exponential backoff, you may not want to configure the max number of attempts ( atMost ), but a deadline. To do so, use either expireIn or expireAt . Deciding to retry # As an alternative to atMost , you can also use until . This method accepts a predicate called after every failure. If the predicate returned true, it retries. Otherwise, it stops retrying and propagates the last failure downstream: 1 2 3 Uni < String > u = uni . onFailure (). retry () . until ( f -> shouldWeRetry ( f ));","title":"Retrying on failures"},{"location":"tutorials/retrying/#retrying-on-failures","text":"It is common to want to retry if something terrible happened. You can retry upon failure. The How does retry\u2026 retries blog post provides a more detailed overview of the retry mechanism. Note If despite multiple attempts, it still fails, the failure is propagated downstream.","title":"Retrying on failures"},{"location":"tutorials/retrying/#retry-multiple-times","text":"To retry on failure, use onFailure().retry() : 1 2 3 4 Uni < String > u = uni . onFailure (). retry (). atMost ( 3 ); Multi < String > m = multi . onFailure (). retry (). atMost ( 3 ); You pass the number of retries as a parameter. Important While .onFailure().retry().indefinitely() is available, it may never terminate, so use it with caution.","title":"Retry multiple times"},{"location":"tutorials/retrying/#introducing-delays","text":"By default, retry retries immediately. When using remote services, it is often better to delay a bit the attempts. Mutiny provides a method to configure an exponential backoff: a growing delay between retries. Configure the exponential backoff as follows: 1 2 3 4 Uni < String > u = uni . onFailure (). retry () . withBackOff ( Duration . ofMillis ( 100 ), Duration . ofSeconds ( 1 )) . atMost ( 3 ); The backoff is configured with the initial and max delay. Optionally, you can also configure a jitter to add a pinch of randomness to the delay. When using exponential backoff, you may not want to configure the max number of attempts ( atMost ), but a deadline. To do so, use either expireIn or expireAt .","title":"Introducing delays"},{"location":"tutorials/retrying/#deciding-to-retry","text":"As an alternative to atMost , you can also use until . This method accepts a predicate called after every failure. If the predicate returned true, it retries. Otherwise, it stops retrying and propagates the last failure downstream: 1 2 3 Uni < String > u = uni . onFailure (). retry () . until ( f -> shouldWeRetry ( f ));","title":"Deciding to retry"},{"location":"tutorials/transforming-items-asynchronously/","tags":["tutorial","beginner"],"text":"Transforming items asynchronously # The previous examples illustrated how to transform each item from a stream into another item. Yet, there are cases where we need to go beyond this, for example: Transforming an item into a Uni \u2013 any asynchronous processing such as calling a remote service, interacting with a database, etc Transforming an item into a Multi \u2013 producing a multi-items stream based on the incoming item, filtering out items, etc Having the possibility to transform an item into a stream gives us many opportunities. To implement such transformations, we use onItem().transformToUni(Function<T, Uni<O>>) and onItem().transformToMulti(Function<T, Multi<O>>) Uni - Transforming an item into a Uni # sequenceDiagram autonumber participant M as Uni participant O as Transformer participant U as Uni(item) participant D as Subscriber M->>O: onItem(item) O--)U: subscribe(...) U--)O: onSubscribe(sub) U--)O: onItem(result) O->>D: onItem(result) Imagine that you have a Uni<String> , and you want to call a remote service. Calling a remote service is an asynchronous action represented by a Uni , as in: 1 Uni < String > invokeRemoteGreetingService ( String name ); To call this service, you need to transform the item received from the first Uni into the Uni returned by the service: 1 2 Uni < String > result = uni . onItem (). transformToUni ( name -> invokeRemoteGreetingService ( name )); This snippet chains the first Uni with another one. The returned Uni ( result ) emits the result from the remote service or a failure if anything wrong happened: 1 2 3 4 5 6 Uni < String > uni = Uni . createFrom (). item ( \"Cameron\" ); uni . onItem (). transformToUni ( name -> invokeRemoteGreetingService ( name )) . subscribe (). with ( item -> System . out . println ( item ), // Print \"Hello Cameron\", fail -> fail . printStackTrace ()); // Print the failure stack trace Uni - Transforming an item into a Multi # The previous example produced a single item. You may want to transform the received item into a stream which is\u2026 a Multi ! 1 2 Multi < String > result = uni . onItem (). transformToMulti ( item -> Multi . createFrom (). items ( item , item )); This code creates a stream of two elements, duplicating the received item. 1 2 3 4 uni . onItem (). transformToMulti ( item -> Multi . createFrom (). items ( item , item )) . subscribe (). with ( item -> System . out . println ( item )); // Called twice sequenceDiagram autonumber participant M as Uni participant O as Transformer participant U as Multi(item) participant D as Subscriber M->>O: onItem(item) O--)U: subscribe(...) U--)O: onSubscribe(sub) U--)O: onItem(item) O->>D: onItem(item) U--)O: onItem(item) O->>D: onItem(item) The produced Multi objects can of course be more complicated than that and emit items in an asynchronous fashion. Transforming items from Multi - the merge vs concatenate dilemma # When transforming items emitted by an upstream Multi, we need to answer the following question: how are we going to merge the produced items back? Let\u2019s take an example. Imagine a Multi emitting the Cameron and Donna items (in order), and you want to call the invokeRemoteGreetingService from above. It thus calls invokeRemoteGreetingService(\"Cameron\") then invokeRemoteGreetingService(\"Donna\") . The service does not have a constant response time (because of network latency or the load), which means that responses can be interleaved. Indeed, you may receive \"Hello Donna\" before \"Hello Cameron\" . Now, how do you want to handle this case? Do you need to preserve the order and ensure that the downstream subscriber will always get \"Hello Cameron\" first, or do you accept interleaved responses? When transforming items from Multi into streams, you need to decide in which order the items emitted by the produced stream are going to be received by the downstream subscriber. Mutiny offers two possibilities: Merging \u2013 it does not preserve the order and emits the items from the produced streams as they come, or Concatenating \u2013 it maintains and concatenates the streams produced for each item. Multi - Transforming an item into a Uni # To implement the scenario from the last section, you will use onItem().transformToUniAndMerge or onItem().transformToUniAndConcatenate() depending on your ordering choice: 1 2 3 4 5 Multi < String > merged = multi . onItem (). transformToUniAndMerge ( name -> invokeRemoteGreetingService ( name )); Multi < String > concat = multi . onItem (). transformToUniAndConcatenate ( name -> invokeRemoteGreetingService ( name )); Multi - Transforming an item into a Multi # onItem().transformToMultiAndMerge and onItem().transformToMultiAndConcatenate transform incoming items into Multi streams. The produced Multi objects are either merged or concatenated : 1 2 3 4 5 Multi < String > merged = multi . onItem (). transformToMultiAndMerge ( item -> someMulti ( item )); Multi < String > concat = multi . onItem (). transformToMultiAndConcatenate ( item -> someMulti ( item ));","title":"Transforming items asynchronously"},{"location":"tutorials/transforming-items-asynchronously/#transforming-items-asynchronously","text":"The previous examples illustrated how to transform each item from a stream into another item. Yet, there are cases where we need to go beyond this, for example: Transforming an item into a Uni \u2013 any asynchronous processing such as calling a remote service, interacting with a database, etc Transforming an item into a Multi \u2013 producing a multi-items stream based on the incoming item, filtering out items, etc Having the possibility to transform an item into a stream gives us many opportunities. To implement such transformations, we use onItem().transformToUni(Function<T, Uni<O>>) and onItem().transformToMulti(Function<T, Multi<O>>)","title":"Transforming items asynchronously"},{"location":"tutorials/transforming-items-asynchronously/#uni-transforming-an-item-into-a-uni","text":"sequenceDiagram autonumber participant M as Uni participant O as Transformer participant U as Uni(item) participant D as Subscriber M->>O: onItem(item) O--)U: subscribe(...) U--)O: onSubscribe(sub) U--)O: onItem(result) O->>D: onItem(result) Imagine that you have a Uni<String> , and you want to call a remote service. Calling a remote service is an asynchronous action represented by a Uni , as in: 1 Uni < String > invokeRemoteGreetingService ( String name ); To call this service, you need to transform the item received from the first Uni into the Uni returned by the service: 1 2 Uni < String > result = uni . onItem (). transformToUni ( name -> invokeRemoteGreetingService ( name )); This snippet chains the first Uni with another one. The returned Uni ( result ) emits the result from the remote service or a failure if anything wrong happened: 1 2 3 4 5 6 Uni < String > uni = Uni . createFrom (). item ( \"Cameron\" ); uni . onItem (). transformToUni ( name -> invokeRemoteGreetingService ( name )) . subscribe (). with ( item -> System . out . println ( item ), // Print \"Hello Cameron\", fail -> fail . printStackTrace ()); // Print the failure stack trace","title":"Uni - Transforming an item into a Uni"},{"location":"tutorials/transforming-items-asynchronously/#uni-transforming-an-item-into-a-multi","text":"The previous example produced a single item. You may want to transform the received item into a stream which is\u2026 a Multi ! 1 2 Multi < String > result = uni . onItem (). transformToMulti ( item -> Multi . createFrom (). items ( item , item )); This code creates a stream of two elements, duplicating the received item. 1 2 3 4 uni . onItem (). transformToMulti ( item -> Multi . createFrom (). items ( item , item )) . subscribe (). with ( item -> System . out . println ( item )); // Called twice sequenceDiagram autonumber participant M as Uni participant O as Transformer participant U as Multi(item) participant D as Subscriber M->>O: onItem(item) O--)U: subscribe(...) U--)O: onSubscribe(sub) U--)O: onItem(item) O->>D: onItem(item) U--)O: onItem(item) O->>D: onItem(item) The produced Multi objects can of course be more complicated than that and emit items in an asynchronous fashion.","title":"Uni - Transforming an item into a Multi"},{"location":"tutorials/transforming-items-asynchronously/#transforming-items-from-multi-the-merge-vs-concatenate-dilemma","text":"When transforming items emitted by an upstream Multi, we need to answer the following question: how are we going to merge the produced items back? Let\u2019s take an example. Imagine a Multi emitting the Cameron and Donna items (in order), and you want to call the invokeRemoteGreetingService from above. It thus calls invokeRemoteGreetingService(\"Cameron\") then invokeRemoteGreetingService(\"Donna\") . The service does not have a constant response time (because of network latency or the load), which means that responses can be interleaved. Indeed, you may receive \"Hello Donna\" before \"Hello Cameron\" . Now, how do you want to handle this case? Do you need to preserve the order and ensure that the downstream subscriber will always get \"Hello Cameron\" first, or do you accept interleaved responses? When transforming items from Multi into streams, you need to decide in which order the items emitted by the produced stream are going to be received by the downstream subscriber. Mutiny offers two possibilities: Merging \u2013 it does not preserve the order and emits the items from the produced streams as they come, or Concatenating \u2013 it maintains and concatenates the streams produced for each item.","title":"Transforming items from Multi - the merge vs concatenate dilemma"},{"location":"tutorials/transforming-items-asynchronously/#multi-transforming-an-item-into-a-uni","text":"To implement the scenario from the last section, you will use onItem().transformToUniAndMerge or onItem().transformToUniAndConcatenate() depending on your ordering choice: 1 2 3 4 5 Multi < String > merged = multi . onItem (). transformToUniAndMerge ( name -> invokeRemoteGreetingService ( name )); Multi < String > concat = multi . onItem (). transformToUniAndConcatenate ( name -> invokeRemoteGreetingService ( name ));","title":"Multi - Transforming an item into a Uni"},{"location":"tutorials/transforming-items-asynchronously/#multi-transforming-an-item-into-a-multi","text":"onItem().transformToMultiAndMerge and onItem().transformToMultiAndConcatenate transform incoming items into Multi streams. The produced Multi objects are either merged or concatenated : 1 2 3 4 5 Multi < String > merged = multi . onItem (). transformToMultiAndMerge ( item -> someMulti ( item )); Multi < String > concat = multi . onItem (). transformToMultiAndConcatenate ( item -> someMulti ( item ));","title":"Multi - Transforming an item into a Multi"},{"location":"tutorials/transforming-items/","tags":["tutorial","beginner"],"text":"Transforming items # Both Unis and Multis emit items . One of the most common operations you will do is transforming these items using a synchronous 1-to-1 function. To achieve this, you use onItem().transform(Function<T, U>) . It calls the passed function for each item and produces the result as an item which is propagated downstream. sequenceDiagram autonumber participant M as Multi participant O as Transformer participant D as Subscriber M->>O: onItem(a1) O->>D: onItem(a2) M->>O: onItem(b1) O->>D: onItem(b2) M->>O: onItem(c1) O->>D: onItem(c2) Transforming items produced by a Uni # Let\u2019s imagine you have a Uni<String>, and you want to capitalize the received String . Implementing this transformation is done as follows: 1 2 3 4 5 Uni < String > someUni = Uni . createFrom (). item ( \"hello\" ); someUni . onItem (). transform ( i -> i . toUpperCase ()) . subscribe (). with ( item -> System . out . println ( item )); // Print HELLO Transforming items produced by a Multi # The only difference for Multi is that the function is called for each item: 1 Multi < String > m = multi . onItem (). transform ( i -> i . toUpperCase ()); The produced items are passed to the downstream subscriber: 1 2 3 4 5 Multi < String > someMulti = Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ); someMulti . onItem (). transform ( i -> i . toUpperCase ()) . subscribe (). with ( item -> System . out . println ( item )); // Print A B C What if the transformation failed? # If the transformation throws an exception, that exception is caught and passed to the downstream subscriber as a failure event. It also means that the subscriber won\u2019t get further item after that failure. Chaining multiple transformations # You can chain multiple transformations: 1 2 3 Uni < String > u = uni . onItem (). transform ( i -> i . toUpperCase ()) . onItem (). transform ( i -> i + \"!\" );","title":"Transforming items"},{"location":"tutorials/transforming-items/#transforming-items","text":"Both Unis and Multis emit items . One of the most common operations you will do is transforming these items using a synchronous 1-to-1 function. To achieve this, you use onItem().transform(Function<T, U>) . It calls the passed function for each item and produces the result as an item which is propagated downstream. sequenceDiagram autonumber participant M as Multi participant O as Transformer participant D as Subscriber M->>O: onItem(a1) O->>D: onItem(a2) M->>O: onItem(b1) O->>D: onItem(b2) M->>O: onItem(c1) O->>D: onItem(c2)","title":"Transforming items"},{"location":"tutorials/transforming-items/#transforming-items-produced-by-a-uni","text":"Let\u2019s imagine you have a Uni<String>, and you want to capitalize the received String . Implementing this transformation is done as follows: 1 2 3 4 5 Uni < String > someUni = Uni . createFrom (). item ( \"hello\" ); someUni . onItem (). transform ( i -> i . toUpperCase ()) . subscribe (). with ( item -> System . out . println ( item )); // Print HELLO","title":"Transforming items produced by a Uni"},{"location":"tutorials/transforming-items/#transforming-items-produced-by-a-multi","text":"The only difference for Multi is that the function is called for each item: 1 Multi < String > m = multi . onItem (). transform ( i -> i . toUpperCase ()); The produced items are passed to the downstream subscriber: 1 2 3 4 5 Multi < String > someMulti = Multi . createFrom (). items ( \"a\" , \"b\" , \"c\" ); someMulti . onItem (). transform ( i -> i . toUpperCase ()) . subscribe (). with ( item -> System . out . println ( item )); // Print A B C","title":"Transforming items produced by a Multi"},{"location":"tutorials/transforming-items/#what-if-the-transformation-failed","text":"If the transformation throws an exception, that exception is caught and passed to the downstream subscriber as a failure event. It also means that the subscriber won\u2019t get further item after that failure.","title":"What if the transformation failed?"},{"location":"tutorials/transforming-items/#chaining-multiple-transformations","text":"You can chain multiple transformations: 1 2 3 Uni < String > u = uni . onItem (). transform ( i -> i . toUpperCase ()) . onItem (). transform ( i -> i + \"!\" );","title":"Chaining multiple transformations"},{"location":"tags-index/","text":"Index # Document kinds # Tag Description tutorial Tutorials to get started with Mutiny. guides Topic-centric guides on how to use Mutiny. reference Reference documents to understand core concepts in Mutiny. Audience level # Tag Description beginner Reading materials if you are new to Mutiny intermediate Intermediate operations beyond the basics advanced Advanced operations beyond classic usage of Mutiny Tags # advanced # Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to deal with dropped exceptions? How can I integrate Mutiny with my framework? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Spying on events Publications beginner # Collecting items from Multi Eliminate duplicates and repetitions Filtering items from Multi How to handle null? Logging events Shortcut methods Take/Skip the first or last items How can I write unit / integration tests? Migrating to Mutiny 2 Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important? Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items guide # Collecting items from Multi Combining items from streams How to deal with CompletionStage? Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to delay events? How to deal with dropped exceptions? Eliminate duplicates and repetitions How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? Filtering items from Multi How can I integrate Mutiny with my framework? How to handle null? How to handle timeouts? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? Joining several unis Kotlin integration Logging events Merging and Concatenating Streams How to use paginated APIs? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Shortcut methods Spying on events Take/Skip the first or last items How can I write unit / integration tests? Dealing with checked exceptions intermediate # Combining items from streams How to deal with CompletionStage? How to delay events? How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? How to handle timeouts? Joining several unis Kotlin integration Merging and Concatenating Streams How to use paginated APIs? Dealing with checked exceptions reference # Migrating to Mutiny 2 Publications Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important? tutorial # Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items","title":"Tags index"},{"location":"tags-index/#index","text":"","title":"Index"},{"location":"tags-index/#document-kinds","text":"Tag Description tutorial Tutorials to get started with Mutiny. guides Topic-centric guides on how to use Mutiny. reference Reference documents to understand core concepts in Mutiny.","title":"Document kinds"},{"location":"tags-index/#audience-level","text":"Tag Description beginner Reading materials if you are new to Mutiny intermediate Intermediate operations beyond the basics advanced Advanced operations beyond classic usage of Mutiny","title":"Audience level"},{"location":"tags-index/#tags","text":"","title":"Tags"},{"location":"tags-index/#advanced","text":"Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to deal with dropped exceptions? How can I integrate Mutiny with my framework? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Spying on events Publications","title":"advanced"},{"location":"tags-index/#beginner","text":"Collecting items from Multi Eliminate duplicates and repetitions Filtering items from Multi How to handle null? Logging events Shortcut methods Take/Skip the first or last items How can I write unit / integration tests? Migrating to Mutiny 2 Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important? Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items","title":"beginner"},{"location":"tags-index/#guide","text":"Collecting items from Multi Combining items from streams How to deal with CompletionStage? Context passing Controlling the demand Using other reactive programming libraries Can I have custom operators? How to delay events? How to deal with dropped exceptions? Eliminate duplicates and repetitions How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? Filtering items from Multi How can I integrate Mutiny with my framework? How to handle null? How to handle timeouts? Hot streams From imperative to reactive How can I create a Multi from a non-reactive source? Joining several unis Kotlin integration Logging events Merging and Concatenating Streams How to use paginated APIs? How to use polling? From reactive to imperative Replaying Multis Using map, flatMap and concatMap Shortcut methods Spying on events Take/Skip the first or last items How can I write unit / integration tests? Dealing with checked exceptions","title":"guide"},{"location":"tags-index/#intermediate","text":"Combining items from streams How to deal with CompletionStage? How to delay events? How to change the emission thread? What is the difference between emitOn and runSubscriptionOn? How to handle timeouts? Joining several unis Kotlin integration Merging and Concatenating Streams How to use paginated APIs? Dealing with checked exceptions","title":"intermediate"},{"location":"tags-index/#reference","text":"Migrating to Mutiny 2 Publications Uni and Multi What is Reactive Programming? What makes Mutiny different? Why is asynchronous important?","title":"reference"},{"location":"tags-index/#tutorial","text":"Creating Multi pipelines Creating Uni pipelines Getting started with Mutiny Handling failures Hello Mutiny! Observing events Retrying on failures Transforming items asynchronously Transforming items","title":"tutorial"}]}